\chapter{Context-Free Languages}
Certain languages like $L \coloneq \{ 0^n 1^n : n \geq 0 \}$ cannot be specified by neither a finite automaton nor a regular expression. To address this, we can use context-free grammars to specify a much larger class of languages.

\begin{dfnbox}{Context-Free Grammar (CFG), Context-Free Language}{}
    A \dfntxt{context-free grammar} consists of a set of production rules that describe how to generate strings. The rules consist of a left-hand side symbol and a right-hand side string. We say a language is \dfntxt{context-free} if it can be generated by a context-free grammar.
    \tcblower
    More formally, a \dfntxt{context-free grammar} can be defined as 4-tuple $(V, \Sigma, R, S)$ where:
    \begin{itemize}[noitemsep]
        \item $V$ is a finite set of symbols called \dfntxt{variables} or \dfntxt{non-terminals}
        \item $\Sigma$ is a finite set of symbols disjoint from $V$ called \dfntxt{terminals}
        \item $R$ is a finite relation from $V$ to $(V \cup \Sigma)^*$ (i.e. a set of \dfntxt{production rules})
        \item $S \in V$ is the \dfntxt{start variable}
    \end{itemize}
    Instead of writing $(a, b) \in R$, we write $a \to b$.
\end{dfnbox}

To generate a string using a CFG, we begin with the start variable $S$. Then, we repeatedly apply the production rules in $R$ to replace a variable with a sequence of symbols until no variables remain in the string. In each step, we choose a variable in the string and use a production rule that has that variable on the left-hand side to generate a new sequence of symbols to replace that variable on the right-hand side. We repeat this process until we have a string consisting only of terminal symbols from $T$.

% A CFG generates strings by the following steps:
% \begin{enumerate}[noitemsep]
%     \item Begin with the start variable $S \in V$.
%     \item Use a rule in $R$ to convert a symbol of the string to another symbol.
%     \item Repeat 2 and 3 until no variables remain in the string.
% \end{enumerate}

\begin{exbox}{Simple CFG}{}
    Suppose CFG $G_1$ has the following specification rules:
    \begin{align*}
        A &\mapsto 0A1 \\
        A &\mapsto B \\
        B &\mapsto \#
    \end{align*}
    The start variable for $G_1$ is $A$. The non-terminals are $A$ and $B$. The terminals are $0$, $1$, and $\#$. An example output may look like:
    \[ 0A1, 00A11, 000A111, 0000B111, 000\#111 \]
    We can add a rule like $B \mapsto \epsilon$ to erase strings. Then the final output would be $000111$.
    \tcblower
    \textbf{Derivation:}
    \[ A \to 0A1 \to 00A11 \to 000A1111 \to 000B111 \to 000\#111 \]
\end{exbox}

\begin{dfnbox}{Direct Derivation}{}
    If $uv,w, \in (V \cup \Epsilon)^*$ and $A \mapsto w \in R$ is a grammar rule, then we say that $uvw$ is \dfntxt{directly derived} from $uAv$ using the rule $A \to w$.
\end{dfnbox}

\begin{exbox}{Language of Simple CFG}{}
    Let $G_3 \coloneq (\{S\}, \{a,b\}, \{S \to aSb | SS | \epsilon\}, S)$ be a CFG. $L(G_3)$ is the language of all strings of properly-nested pair-delimiters (e.g. parentheses or brackets).
\end{exbox}

\begin{exbox}{Another Language of Simple CFG}{}
    Let $G_3 \coloneq (\{E,T,F\}, \{a, +, *, (, )\}, R, E)$ where $R$ is given by:
    \[ E \mapsto E + T | T,\quad T \mapsto T * F | F,\quad F \mapsto (E) | a \]
    $L(G_4)$ is the language of some arithmetic expressions.
\end{exbox}

\begin{dfnbox}{Ambiguous Grammar}{}
    A grammar is considered \dfntxt{ambiguous} if it can generate the same string in different ways.
\end{dfnbox}

\section{Design Techniques}
Many CFGs are unions of simpler CFGs. Combination involves putting all the rules together and adding the new rules.

\todo{Derivations, parse trees}

\section{Chomsky Normal Form}

\begin{dfnbox}{Chomsky Normal Form (CNF)}{}
    A context-free grammar is in \dfntxt{Chomsky normal form} if every rule is of the form:
    \begin{itemize}
        \item $A \to BC$ (a variable produces two variables)
        \item $A \to a$, (a variable produces a terminal)
    \end{itemize}
    where $a$ is a terminal, $A,B,C$ are any variables, and $B,C$ aren't the start variable. We also allow the rule $S \to \epsilon$ where $S$ is the start variable.
\end{dfnbox}

CNF can simplify any context-free grammar to a (usually very unbalanced) binary tree.

\begin{thmbox}{ASdf}{}
    Any context-free language can be generated by a context-free grammar in Chomsky normal form.
    \tcblower
    \textbf{Intuition:} We want to remove any possible recursive rules involving the start variable on the right-hand side. Thus, we simply create a new start variable that maps to the old start variable.

    \begin{proof}

    \end{proof}
\end{thmbox}

\begin{tecbox}{}{}
    \begin{enumerate}
        \item Add a new start variable $S_0$ and rule $S_0 \to S$, where $S$ was the original start variable.
        \item Eliminate all $\epsilon$ rules. (Repeat the following steps until done)
        \begin{enumerate}
            \item Eliminate the rule $A \to \epsilon$ where $A$ is not the start variable.
            \item For each occurrence of $A$ on the right-hand side of a rule, add a new rule with that occurrence of $A$ deleted.
            \item If there exists a rule $B \to A$, replace it with $B \to A | \epsilon$ unless the rule $B \to \epsilon$ has not been eliminated.
        \end{enumerate}
        \item Remove all unit rules. (Repeat the following steps until done)
        \begin{enumerate}
            \item Remove any unit rule $A \to B$ (i.e. any rule that replaces one character with strictly one other character)
            \item For each rule $B \to u$, add the rule $A \to u$, unless it was a previously removed unit rule
        \end{enumerate}
        \item Convert all remaining rules (Repeat until no rules of the form $A \to u_1 u_2 \ldots u_k$ with $k \geq 3$ remain)
        \begin{enumerate}
            \item Re
        \end{enumerate}
    \end{enumerate}
\end{tecbox}

\section{Pushdown Automata}
\begin{dfnbox}{Pushdown Automata}{}
    A \dfntxt{pushdown automaton} is an NFA with the addition of a \dfntxt{stack} that can store characters in a last in, first out (LIFO) structure.
    \tcblower
    Formally, a \dfntxt{pushdown automaton} is defined as a 6-tuple $(Q, \Sigma, \Gamma, \delta, q_0, F)$ where:
    \begin{itemize}[noitemsep]
        \item $Q$ is a set of states
        \item $\Sigma$ is the input alphabet
        \item $\Gamma$ is the stack alphabet
        \item $\delta : Q \times (\Sigma \cup \{\epsilon\}) \times (\Sigma \cup \{\epsilon\}) \to \mathcal{P}(Q \times (\Gamma \cup \epsilon))$ is a transition function
        \item $q_0 \in Q$ is the start state
        \item $F \subseteq Q$ is the set of accept states
    \end{itemize}
    We write $a,b\to c$ to mean whenever the machine reads $a$, it can choose to pop the top element of the stack if it is a $b$, and replace it with $c$
\end{dfnbox}

In this context, the stack is just some memory where we can only access the most recently added element. We can choose to remove or \dfntxt{pop} the top element, or we could \dfntxt{push} a new element onto the stack. The addition of the stack allows$\ldots$\todo{wat}

A PDA computes as follows:
\begin{enumerate}
    \item We input some string over the alphabet $\Sigma \cup \{\epsilon\}$.
    \item The machine \todo{finish this}
\end{enumerate}

A language specified by a context-free grammar can be recognized by a pushdown automaton.
\begin{thmbox}{Context-Free Regularity}{}
    A language is context-free if and only if some pushdown automaton recognizes it.
    \tcblower
    \begin{proof}

    \end{proof}
\end{thmbox}

\todo[inline]{Parse table}
\begin{exbox}{Parse Table}{}
    Consider the following grammar for well-formed parentheses and brackets:
    \begin{align}
        P &\to S\$\$ \\
        S &\to (S)S \\
        S &\to [S]S \\
        S &\to \epsilon
    \end{align}

    We can create a \dfntxt{parse table} that checks if a string conforms with the grammar.

    \begin{center}\begin{tabular}{r | c c c c c}
        Variable & ( & ) & [ & ] & \$\$ \\ \hline
        $P$ & 1 & --- & 1 & --- & 1 \\
        $S$ & 2 & 4 & 3 & 4 & 4
    \end{tabular}\end{center}

    \begin{center}\begin{tabular}{c | c | c}
        Parse Stack & Input Stream & Comment \\ \hline
        $P$ & ([]([]))[](())\$\$ & \\
        $S\$\$$ & ([]([]))[](())\$\$ & Predict $P \to S\$\$$ \\
        $(S)S\$\$$ & ([]([]))[](())\$\$ & Predict $S \to (S)\$\$$ \\
        $S)S\$\$$ & []([]))[](())\$\$ & Match $($ \\
        $[S]S)S\$\$$ & []([]))[](())\$\$ & Predict $S \to [S]S$ \\
        $S]S)S\$\$$ & $]([]))[](())\$\$$ & Match $[$ \\
        $]S)S\$\$$ & $]([])[](())\$\$$ & Predict $S \to \epsilon$ \\
        $S)S\$\$$ & $([]))[](())\$\$$ & Match $]$
    \end{tabular}\end{center}
\end{exbox}

\begin{thmbox}{Pumping Lemma for Context-Free Languages}{}
    If $A$ is a context-free language, then there exists some $p \in \N$ (the pumping length) such that for all $s \in A$ where $\abs{s} \geq p$, $s$ can be divided into five substrings, $s = uvxyz$, satisfying the following three conditions:
    \begin{enumerate}[noitemsep]
        \item $\forall (i \geq 0) (uv^ixy^iz \in A)$,
        \item $\abs{vy} > 0$, and
        \item $\abs{vxy} \leq p$.
    \end{enumerate}
    \tcblower
    \begin{proof}[Proof sketch]
        Let $A$ be a CFL, and let $G$ be a CFG that generates $A$. Let $p$ be the pumping length for $A$. We have to show that any $s \in A$ of length $p$ can be pumped and remain in $A$.
        \begin{itemize}[noitemsep]
            \item Since $s \in A$, then it can be derived from $G$. Let $D_s$ denote the derivation tree for $s$.
            \item The tree $D_s$ is probably very tall (for a long $s$).
            \item So $D_s$ contains some relatively long path from the start variable to a terminal (i.e. leaf in $D_s$).
            \item By the Pigeonhole Principle (todo: ref), some variable $X$ must be repeated.
            \item The repetition of $X$ allows $s$ to be pumped.
        \end{itemize}
    \end{proof}
\end{thmbox}

\begin{exbox}{Using Pumping Lemma to Prove a CFL is not Regular}{}
    Prove that the language $B \coloneq \{ a^n b^n c^n : n \geq 0 \}$ is not a context-free language.
    \tcblower
    \begin{proof}
        Suppose for contradiction that $B$ is a context-free language. Let $P$ be the pumping length for $B$. Let $s \coloneq a^p b^p c^p \in B$. Since $\abs{s} \geq p$, then the Pumping Lemma guarantees that $s$ may be divided into five substrings, $s = uvxyz$, satisfying the following three conditions:
        \begin{enumerate}[noitemsep]
            \item $\forall (i \geq 0) (uv^ixy^iz \in B)$,
            \item $\abs{vy} > 0$, and
            \item $\abs{vxy} \leq p$.
        \end{enumerate}
        Let $s\prime \coloneq uv^2xy^2z \in B$. Let's consider the ramifications of condition 2 for the contents of $v$ and $y$. We will do a case-by-case analysis.
        \begin{itemize}
            \item If both $v$ and $y$ contain only one type of symbol, or $v$ and $y$ does not contain both $a$'s and $b$'s, or $v$ and $y$ does not contain both $b$'s and $c$'s, then $s\prime \notin B$, contradicting condition 1.
            \item If either $v$ or $y$ contain more than one type of symbol, then $uv^2xy^2z$ may contain equal numbers of the three symbols but not in the correct order. Thus, $s\prime \notin B$, contradicting condition $1$.
        \end{itemize}
        Since one of the two cases must occur for any $s$, we can conclude
    \end{proof}
\end{exbox}
