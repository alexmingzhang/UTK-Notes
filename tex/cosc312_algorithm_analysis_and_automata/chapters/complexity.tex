\chapter{Complexity}

Complexity in terms of Turing Machines deals with the number of steps the machine takes to finish computation. In general, the running time of an algorithm is a function of the length of the string that represents the input.

\section{Asymptotic Analysis}

\begin{dfnbox}{Big-O, Little-O}{}
    Intuitively, a function $f$ is (in) \dfntxt{Big O} of $g$ (written $f \in \bigO(g)$) if $f$ grows no faster than $g$. A function $f$ is (in) \dfntxt{Little O} of $g$ (written $f \in \littleO(g)$) if $f$ grows strictly slower than $g$.
    \tcblower
    Formally, let $g : \N \to \R$ be a function. We define \dfntxt{Big-O} of $g$ as:
    \[ \bigO(g) \coloneq \left\{ f : \N \to \R \mid \exists (k > 0) \exists (a \in \N) (x > a \implies 0 \leq f(x) \leq g(x)) \right\} \]
    We define \dfntxt{Little-O} of $g$ as:
    \[ \littleO(g) \coloneq \left\{ f : \N \to \R \mid \forall (k > 0) \exists (a \in \N) (x > a \implies 0 \leq f(x) \leq g(x)) \right\} \]
\end{dfnbox}

\section{P, NP, NP-Hard, NP-Complete}

In complexity theory, we have four distinct sets of problems:
\begin{itemize}
    \item $P$ (polynomial time): the set of decision problems that can be solved in polynomial time
    \item $NP$ (non-deterministic polynomial time): the set of decision problems that can be verified in polynomial time
    \item $NP$-Hard: the set of decision problems that are at least as hard as the hardest problems in $NP$. More formally, a problem is $NP$-hard if every $NP$ problem can be reduced to the $NP$-hard problem in polynomial time. So if we could solve an $NP$-hard problem in polynomial time, then we can solve any $NP$ problem in polynomial time.
    \item $NP$-cComplete: the set of decision problems that are $NP$ and $NP$-hard. 
\end{itemize}

% We denote ${P}$ to be the class of all languages decidable by a single-tape Turing machine in \textbf{polynomial time}. It roughly corresponds to the class of problems that are feasibly solvable by computers.

% \[ P \coloneq \bigcup_k \TIME(n^k) \]

% \begin{dfnbox}{Verifier}{}
%     A \dfntxt{verifier} for a language $A$ is an algorithm $V$ where:
%     \[ A \coloneq \{ w : V\ \text{accepts}\ \alg{w,c}\ \text{for some string}\ c \} \]
% \end{dfnbox}

% The running time of a verifier is measured in terms of the length of $w$. A polynomial-time verifier runs in polynomial time in length of $w$. We say that a language $A$ is polynomial verifiable if there exists a \dfntxt{polynomial-time verifier} that verifies the language.

% \begin{thmbox}{Context-Free Languages are Polynomial Time}{}

% \end{thmbox}

% \paragraph{$P$ v.s. $NP$}
% While problems in ${P}$ 

% \paragraph{${P} = {NP}$?}

% This is one of the largest unsolved problems in theoretical computer science. If there were a polynomial-time algorithm for certain problems in $\mathscr{NP}$, then it would follow that all problems in $\mathscr{NP}$ have a polynomial-time solution. Such problems are called \dfntxt{NP-Complete}.

\section{Dynamic Programming}

If we wanted to prove that every context-free language is a member of $P$, we can deploy a dynamic programming algorithm to determine whether each variable in a context-free grammar $G$ generates each substring of a given string $w \coloneq w_1 w_2 \cdots w_n$ in the language generated by $G$. The algorithm enters the solution to each sub-problem into an $n \times n$ table. For $i \leq j$, the $(i,j)$ entry of the table contains the collection of variables that generate the substring $w_i w_{i+1} \cdots w_j$. For $i > j$, the table entries are unused.
