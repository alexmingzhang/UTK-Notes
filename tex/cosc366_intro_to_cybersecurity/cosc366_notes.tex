\documentclass[code]{amznotes}

\title{\textbf{Introduction to Cybersecurity}\\
\large UT Knoxville, Spring 2023, COSC 366}
\author{Dr. Scott Ruoti, Alex Zhang}

\begin{document}

\maketitle
\tableofcontents

\chapter{Security Concepts and Principles}

\section{Fundamental Goals of Computer Security}

\begin{dfnbox}{Computer Security}{computer-security}
    \dfntxt{Computer security} is the practice of protecting computer-related assets from unauthorized actions, either by preventing such actions or detecting and recovering from them.
\end{dfnbox}

The goal of \nameref{dfn:computer-security} is to help users complete their desired task safely, without short or long term risks.  To do this, we support computer-based services by providing essential security properties.

\begin{dfnbox}{Confidentiality, Integrity, Availablity (CIA)}{cia}
    \begin{itemize}[noitemsep]
        \item \dfntxt{Confidentiality}: only authorized parties can access data, whether at rest or in motion (i.e. being transmitted)
        \item \dfntxt{Integrity}: data, software, or hardware remaining unchanged, except by authorized parties
        \item \dfntxt{Availability}: information, services, and computing resources are available for authorized use
    \end{itemize}
    Together, these form the \dfntxt{CIA triad}.
\end{dfnbox}

\begin{dfnbox}{Principal, Privilege}{}
    A \dfntxt{principal} is an entity with a given identity, such as a user, service, or system process. A \dfntxt{privilege} defines what a principal can do, such as read/write/execute permissions.
\end{dfnbox}

In addition to the CIA triad, we also have three security properties relating to principals.
\begin{dfnbox}{Authentication, Authorization, Auditability (Golden Principles)}{}
    The \dfntxt{Golden Principles} are three security properties regarding principals:

    \begin{itemize}[noitemsep]
        \item \dfntxt{Authentication:} assurance that a principal is who they say they are
        \item \dfntxt{Authorization:} determining whether a requested privilege or resource access should be granted to the requesting principal
        % \item \dfntxt{Authorization}: proof that an entity has the necessary privilege to take the request action; most commonly done by authenticating a principal, and lookup up its privileges
        \item \dfntxt{Auditability:} ability to identify principals responsible for past actions
    \end{itemize}

\end{dfnbox}

Auditability (or accountability) gives away two key things: who conducted the attack and the methods by which an attack was made.

\begin{dfnbox}{Trustworthy, Trusted}{}
    Something is \dfntxt{trustworthy} if it deserves our confidence.     Something is \dfntxt{trusted} if it has our confidence.

\end{dfnbox}

\begin{dfnbox}{Privacy, Confidentiality}{}
    \dfntxt{Privacy} is a sense of being in control of access that others have to ourselves. It deals exclusively with people. \dfntxt{Confidentiality} is an extension of privacy to also include personally sensitive data.
\end{dfnbox}

\section{Computer security policies and attacks}

\begin{dfnbox}{Asset}{asset}
    An \dfntxt{asset} is a resource we want to protect, such as information, software, hardware, or computing/communications services.
\end{dfnbox}

Note that asset can refer to any tangible or intangible resources.

\begin{dfnbox}{Security Policy}{}
    A \dfntxt{security policy} specifies the design intent of a system's rules and practices (i.e. what the system is supposed to do and not do).
\end{dfnbox}

\begin{dfnbox}{Adversary}{}
    An \dfntxt{adversary} is an entity who wants to violate a security policy to harm an asset. Can also be called ``threat agents'' or ``threat actors''. Some attributes of an adversary include:
    \begin{itemize}[noitemsep]
        \item \dfntxt{identity}: who are they?
        \item \dfntxt{objectives}: what assets the adversary might try to harm
        \item \dfntxt{methods}: the potential attack techniques or types of attacks
        \item \dfntxt{capabilities}: skills, knowledge, personnel, and opportunity
    \end{itemize}
\end{dfnbox}

A formal security policy should precisely define each possible system state as either authorized (secure) or unauthorized (non-secure). Non-secure states raise the potential for attacks to happen.

\begin{dfnbox}{Threat}{}
    A \dfntxt{threat} is any combination of circumstances and/or entities that allow harm to assets or cause security violations.
\end{dfnbox}

\begin{dfnbox}{Attack, Attack Vector}{attack}
    An \dfntxt{attack} is a deliberate attempt to cause a security violation. An \dfntxt{attack vector} is the specific methods and steps by which an attack was executed.

\end{dfnbox}

\begin{dfnbox}{Mitigation}{mitigation}
    \dfntxt{Mitigation} describes countermeasures to reduce the chance of a threat being actualized or lessen the cost of a successful attack.
\end{dfnbox}

\nameref{dfn:mitigation} can include operational and management processes, software controls, and other security mechanisms.

\begin{exbox}{House Security Policy}{house}
    Consider this simple security policy for a house: no one is allowed in the house unless accompanied by a family member, and only family members are authorized to take things out of the house.
    \begin{itemize}[noitemsep]
        \item The presence of someone who wants to steal an asset from our house is a \textbf{threat}.
        \item An unaccompanied stranger in the house is a \textbf{security violation}.
        \item An unlocked door is a \textbf{vulnerability}.
        \item A stranger entering through the unlocked door and stealing a television is an \textbf{attack}.
        \item Entry through the unlocked door is an \textbf{attack vector}.
    \end{itemize}
\end{exbox}

\section{Risk, risk assessment, and modeling expected losses}

\begin{dfnbox}{Risk}{risk}
    A \dfntxt{risk} is the expected loss of assets due to future attacks.
\end{dfnbox}

There are two ways we assess risk: \dfntxt{quantitative} and \dfntxt{qualitative} risk assessment.
\begin{itemize}
    \item \dfntxt{Quantitative} risk assessment computes numerical estimate of risk
    \item \dfntxt{Qualitative} risk assessment compares risks relative to each other
\end{itemize}

Quantitative risk assessment is more suited for incidents that occur regularly, with historical data and stable statistics to generate probability estimates. However, computer security incidents occur so infrequently that any estimate of probability likely isn't precise. Thus, qualitative risk assessment is usually more practical. For each asset or asset class, their relevant threats are categorized based on probability of happening and impact if it happened.

Precise estimates of risk are rarely possible in practice, so qualitative risk assessment is usually yields more informed decisions. A popular equation for modeling risk is:
\[ R = T \cdot V \cdot C \]
where:
\begin{itemize}
    \item $T$ is the probability of an attack happening,
    \item $V$ is the probability such a vulnerability exists, and
    \item $C$ is cost of a successful attack, both tangible and intangible costs
\end{itemize}

$C$ can encompass tangible losses like money or intangible losses like reputation. Whatever model we use, we can then model expected losses as such:

In risk assessment, we ask ourselves these questions:
\begin{enumerate}
    \item What assets are most valuable, and what are their values?
    \item What system vulnerabilities exist?
    \item
\end{enumerate}

In answering these questions, it becomes apparant we cannot employ strictly quantitative risk assessment. A popular model for qualitative risk assessment is the \nameref{dfn:dread} model:

\begin{dfnbox}{DREAD}{dread}
    \dfntxt{DREAD} is a method of qualitative risk assessment using a subjective scaled rating system for five attributes.

    \begin{center}\begin{tabular}{r | l | l}
        Attribute & 10 & 1 \\ \hline
        \dfntxt{Damage Potential} & data is extremely sensitive & data is worthless \\
        \dfntxt{Reproducibility} & works every time & works only once \\
        \dfntxt{Exploitability} & anyone can mount an attack & requires a nation state \\
        \dfntxt{Affected Users} & 91-100\% of users & 0\% of users \\
        \dfntxt{Discoverability} & threat is obviously apparent & threat is undetectable
    \end{tabular}\end{center}

    The final DREAD score takes the average of all five attributes.
\end{dfnbox}

A common criticism of \nameref{dfn:dread} is that rating discoverability might reward security through obscurity. People will sometimes omit discoverability, or simply assign it the maximum value all the time.


\[ ALE = \sum_{i=1}^{n} F_i \cdot C_i \]
where:
\begin{itemize}
    \item $F_i$ is the estimated frequency of events of type $i$, and
    \item $C_i$ is the average loss expected per occurence of an event of type $i$
\end{itemize}

\section{Adversary modeling and security analysis}

% Commented because we already defined adversary in a previous section
% \begin{dfnbox}{Adversary}{}
%     An \dfntxt{adversary} is an entity that wants to violate a security policy in order to harm an asset.
%     \begin{itemize}[noitemsep]
%         \item \dfntxt{identity}: who are they?
%         \item \dfntxt{objectives}: what assets the adversary might try to harm
%         \item \dfntxt{methods}: the potential attack techniques or types of attacks
%         \item \dfntxt{capabilities}: skills, knowledge, personnel, and opportunity
%         % \item funding level -- how much money an attacker has
%         % \item outsider or insider -- whether or not the adversary may have special permissions or privileges
%     \end{itemize}
% \end{dfnbox}

In designing computer security mechanisms, it is important to think like an adversary. Try to enumerate what methods might they use, and design around them. Different adversaries can have wildly different objectives, methods, and capabilities.

\begin{dfnbox}{Security Analysis}{}
    \dfntxt{Security analysis} aims to identify vulnerabilities and overlooked threats, as well as ways to improve defense against such threats
\end{dfnbox}

Types of analysis include:
\begin{itemize}[noitemsep]
    \item \dfntxt{Formal security evaluation}: standardized testing to ensure essential features and security
    \item \dfntxt{Internal vulnerability testing}: internal team trying to find vulnerabilities
    \item \dfntxt{External penetration testing}: third-party audits to find vulnerabilities; often the most effective
\end{itemize}

Security analysis is a heavily involved process that may employ a variety of methodologies. For example, manual source code review, review of design documents, and various penetration testing techniques. It's important to be aware of potential vulnerabilities as we are writing code.

\section{Threat Modeling}
A threat model will identify possible adversaries, threats, and attack vectors. We need to list a set of assumptions about the threats as well as clarify what is in and out of the scope of possibilities.

\paragraph{Diagram-Driven Threat Model}
Threat model diagrams include assets, infrastructure, and defenses/mitigations, making apparent the possible attack vectors. Popular examples include:
\begin{itemize}[noitemsep]
    \item \dfntxt{Data Flow Diagrams:} models all possible data routes
    \item \dfntxt{User Workflow Diagram:} models how users interact with the program, both frontend and backend
    \item \dfntxt{Attack Trees:} models all possible attack vectors like a flow chart; leaf nodes are initial actions
\end{itemize}

\begin{dfnbox}{STRIDE}{stride}
    \dfntxt{STRIDE} is a model for enumerating and identifying possible computer security threats.
    \begin{itemize}[noitemsep]
        \item \dfntxt{Spoofing:} attacker impersonates another user, or malicious server posing as a legitimate server
        \item \dfntxt{Tampering:} altering data without proper authorization; can occur when data is stored, processed
        \item \dfntxt{Repudiation:} lying about past actions (e.g. denying/claiming that something happened)
        \item \dfntxt{Information Disclosure:} exposure of confidential information without authorization
        \item \dfntxt{Denial of Service:} render service unusable or unreliable for users
        \item \dfntxt{Elevation of Privilege:} an unprivileged user gains privileges
    \end{itemize}
\end{dfnbox}

\section{Threat Model Gaps}
Often, wrong assumptions about risk or focus on wrong threats will lead to gaps between our threat model and what can realistically happen (e.g. if we don't account for something, but it does happen).

\paragraph{Changing Times}
New adversaries, technologies, software, and controls means we need to constantly adjust our threat model.

\section{Design Principles}
\begin{enumerate}
    \item \dfntxt{Simplicity and necessity:} complexity increases risks (KISS: keep it simple, stupid)
    \item \dfntxt{Safe Defaults:} ensure default settings are secure; users rarely change defaults
    \item \dfntxt{Open Design:} don't rely on the secrecy of our code; just assume it will leak
    \item \dfntxt{Complete Mediation:} never assume access is safe; always check access is allowed
    \item \dfntxt{Least Privilege:} don't give principals extraneous privileges; limit impact of compromise
    \item \dfntxt{Defense in depth:} multiple layers of security; don't rely on only one security control
    \item \dfntxt{Security by design:} think about security throughout development, not an afterthought
    \item \dfntxt{Design for evolution:} allow for change for whenever it's needed
\end{enumerate}

Overall, computer security is hard! \todo{explain why tho}

% \section{Review}
% CIA Triad, Golden principles, trusted vs. trustworthy, confidentialty vs. privacy.

% TODO: add more review stuff from slides here; flesh out notes to reflect review

\chapter{Cryptography}
Whenever working with cryptography, always remember:
\begin{enumerate}[noitemsep]
    \item Do not design your own cryptographic protocols or algorithms. Your design will almost always be flawed.
    \item \dfntxt{Kerckhoff's Principle:} Security should only come from the secrecy of the crytographic key, NOT the algorithm or code. In other words, just assume that any adversary can view your source code.
    \item Encryption only provides \dfntxt{confidentiality}, not integrity. That is, encryption only keeps your data secret, but an attacker could still modify the encrypted data.
\end{enumerate}

\section{Introduction}

\begin{dfnbox}{Cipher, Plain Text, Cipher Text}{}
    A \dfntxt{cipher} is any encryption or decryption algorithm. A \dfntxt{plaintext} message is a message prior to cipher and is thus vulnerable. A \dfntxt{ciphertext} message is after the cipher is applied.
\end{dfnbox}

Some possible threats to encryption may be:
\begin{itemize}[noitemsep]
    \item \dfntxt{Brute force attack:} guess and check all keys
    \item \dfntxt{Algorithmic break:} some flaw in the encryption algorithm
\end{itemize}

\begin{dfnbox}{Cryptographic Key, Key Space}{}
    A \dfntxt{cryptographic key} is a value which is used to decrypt cipher text. It should be relatively large and remain private. The \dfntxt{key space} is the set of all possible cryptographic keys in a cipher.
\end{dfnbox}

The key space for a cipher should be large enough such that it would be impractical for an attacker to perform a brute force attack. For example, AES-256 uses 256-bit keys. The key space of AES-256 contains $2^{256}$ distinct keys. Even a thermodynamically perfect computer with the power of the sun could not even count through $2^{256}$ keys, much less guess and check them!

\begin{dfnbox}{Passive Adversary, Active Adversary}{}
    A \dfntxt{passive adversary} only observes and records communications. An \dfntxt{active adversary} interacts with and/or modifies communications, possibly by injecting data, altering data, or starting new interactions with legitimate parties.
\end{dfnbox}

% Some possible adversaries include:
% \begin{itemize}[noitemsep]
%     \item Passive -- just listens to communications
%     \item Active -- can modify data
% \end{itemize}

\begin{dfnbox}{Information-Theoretic Security}{}
    We say ciphertext has \dfntxt{information-theoretic security} if given \textbf{unlimited} computer power and time, an attacker could not recover the plaintext from the ciphertext.
\end{dfnbox}

\begin{dfnbox}{Computational Security}{}
    We say ciphertext has \dfntxt{computational security} if given \textbf{fixed} computer power and time, an attacker could not recover the plaintext from the ciphertext.
\end{dfnbox}

\begin{dfnbox}{Stream Cipher, Block Cipher}{}
    A \dfntxt{stream cipher} encrypts information one bit at a time.     A \dfntxt{block cipher} encrypts information in blocks.
\end{dfnbox}

\section{Symmetric Encryption Model}

\begin{dfnbox}{Symmetric-Key Encryption}{}
    \dfntxt{Symmetric-key encryption} uses the same cryptographic key to encrypt plaintext and decrypt ciphertext.
\end{dfnbox}

\begin{dfnbox}{One-Time Pad (OTP)}{}
    The \dfntxt{one-time pad} is a symmetric stream cipher that simply XOR's a message with a key of equal length. The resulting ciphertext is information theoretic so long as the cryptographic key is:
    \begin{itemize}[noitemsep]
        \item as long as the plaintext,
        \item completely randomly generated,
        \item never reused, and
        \item kept completely secret between authorized parties.
   \end{itemize}
\end{dfnbox}

Many modern cryptographic algorithms work by taking a small cryptographic key and expanding it into a sufficiently large one-time pad key.

\begin{dfnbox}{Advanced Encryption Standard (AES)}{}
    \dfntxt{AES} is the most common symmetric block cipher.
    \begin{itemize}[noitemsep]
        \item Messages are split into 128-bit blocks (with padding)
        \item Cryptographic key is 128, 196, or 256 bits long
        \item Provides computational security
        \item A single bit changed should change (on average) 50\% of the ciphertext
    \end{itemize}
    In addition, different block modes help to remove patterns among blocks.
\end{dfnbox}

\section{Asymmetric Encryption Model}

\begin{dfnbox}{Asymmetric Encryption, Public Key, Private Key}{}
    \dfntxt{Asymmetric encryption} utilizes two cryptographic keys: a \dfntxt{public key} which encrypts plaintext, and a \dfntxt{private key} which decrypts ciphertext.
\end{dfnbox}

Unfortunately, public key encryption is orders of magnitude slower than symmetric key encryption. We can incorporate both using hybrid encryption, providing the best of both worlds.

\begin{dfnbox}{Hybrid Encryption, Key Wrap}{}
    \dfntxt{Hybrid encryption} incorporates both symmetric key and public key encryption. We encrypt our plaintext using a symmetric key, and we send both the encrypted ciphertext and the symmetric key encrypted using the other party's public key. This encrypted key is called a \dfntxt{key wrap}.
\end{dfnbox}

\begin{dfnbox}{Padding}{}
    Many encryption algorithms \dfntxt{pad} messages to:
    \begin{itemize}[noitemsep]
        \item ensure the message is properly formatted
        \item prevent attacks by adding random noise
    \end{itemize}
\end{dfnbox}

To see why padding is important, suppose we only need to send a single integer. While the key space is large, the message space is small. Thus, an attacker could guess and check all possible messages until it matches the encrypted message.

There are many ways to pad a message. Generally, we want to use the optimal asymmetric encryption padding (OAEP).

\begin{dfnbox}{RSA}{}
    \dfntxt{RSA} is a common and mathematically simple cryptographic algorithm that provides computational security.
\end{dfnbox}

\begin{codebox}{RSA Encryption using C\#}{}{}
    \begin{amzcode}{csharp}
        var message = "Hello World!";
        var plaintext = Encoding.ASCII.GetString(ciphertext);
        var rsa = RSA.Create(2048);
        var public_key = rsa.ExportRSAPublicKeyPem();
        var private_key = rsa.exportRSAPrivateKeyPem();

        var ciphertext = rsa.Encrypt(plaintext, RSAEncryptionPadding.OaepSHA256);

        var decrypted = rsa.Decrypt(ciphertext, RSAEncryptionPadding.OaepSHA256);
        var decrypted_plaintext = Encoding.ASCII.GetString(decrypted);
    \end{amzcode}
\end{codebox}

\section{Digital Signatures}

\begin{dfnbox}{Digital Signature}{}
    \dfntxt{Digital signatures} are tags (bitstrings) that accompany a message, verifying that data came from the right person. The \dfntxt{private key} is used to sign data, and the \dfntxt{public key} to verify a signature.
\end{dfnbox}

Digital signatures provide three security properties:
\begin{enumerate}[noitemsep]
    \item \dfntxt{Data origin authentication:} the data comes from the owner of the private key
    \item \dfntxt{Data integrity:} the data has not changed since it was sent
    \item \dfntxt{Non-repudiation:} the sender cannot later claim to have not sent the data
\end{enumerate}

In practice, digital signatures provide non-repudiation if and only if nobody besides the legitimate party has the private key for signing. They could try to deny ever signing something by saying ``someone must have stolen and used my private key.''

It is \textbf{crucial} to avoid using the same key for signing and for cryptography because:
\begin{enumerate}[noitemsep]
    \item If our private key gets stolen, someone can then decrypt our data \textbf{and} forge our digital signatures.
    \item There can be strange mathematical interactions between encryption and signing that might reveal information about our key.
\end{enumerate}

Similar to encryption algorithms, there are signing algorithms that create digital signatures and verification algorithms that verify digital signatures. In addition, we still pad our messages before signing to ensure the message is formatted and to prevent some (relatively esoteric) attacks.

Data is often hashed before signed. Again, different key pairs should be used for encryption/decryption and signing/verification.

\section{Cryptographic Hash Functions}

\begin{dfnbox}{Hash Function}{}
    A \dfntxt{hash function} takes a string of \textbf{any length} and outputs a (relatively) unique string of \textbf{fixed length}.
    % \tcblower
    % \[ H : 2^* \to 2^n \]
\end{dfnbox}

The output of a hash function can be called a \dfntxt{hash value}, \dfntxt{digest}, or simply \dfntxt{hash}. In practice, hash functions should always:
\begin{enumerate}[noitemsep]
    \item be applicable to data of any size,
    \item output a fixed length data, and
    \item be fast to compute.
\end{enumerate}

Hash functions should also guarantee three essential security properties:
\begin{enumerate}[noitemsep]
    \item \dfntxt{One-way property}: Theoretically impossible to find the original message from the hash; one hashed string maps to an infinite amount of input strings (sometimes called preimage resistance)
    \item \dfntxt{Weak collision resistance}: Given an input, it's computationally impossible to find another input that produces the same hash.
    \item \dfntxt{Strong collision resistance}: It's computationally impossible to find any pair of distinct inputs that produce the same hash.
\end{enumerate}

\begin{dfnbox}{SHA}{}
    \dfntxt{SHA} is a common hash function.
\end{dfnbox}

\begin{exbox}{Data Integrity}{}
    \begin{itemize}
        \item When sending data, first hash it and send the hash along with the data
        \item When receiving the data, first hash it and check that the calculated hash matches the one that was received
        \item TODO: finish from slides
    \end{itemize}
\end{exbox}

\begin{exbox}{Password Storage}{}
    Instead of storing passwords in plaintext, the server stores the hashed passwords.

    Hashing at client and then sending to server is flawed!
    \begin{itemize}
        \item If an attacker steals the hashed passwords, an attack can simply log in using the hashed passwords.
    \end{itemize}
\end{exbox}

\section{Message Authentication Codes}

\begin{dfnbox}{Message Authentication Code (MAC)}{}
    A \dfntxt{message authentication code} is a tag (or bitstring) used for authenticating a message (i.e. came from the right person).
\end{dfnbox}

\begin{itemize}[noitemsep]
    \item Symmetric-key equivalent to digital signatures
    \item Provides data origin authentication and data integrity (only for two people)
\end{itemize}

In practice, message authentication codes \textbf{do not} provide non-repudiation. At least two people will have access to the key (which is used for signing and authenticating). Thus, a third party won't be able to tell who created the MAC.

\begin{dfnbox}{Hash-Based Message Authentication Code (HMAC)}{}
    Can be used with any cryptographic hash function, only use with safe functions (e.g. HMAC-SHA256)
\end{dfnbox}

\begin{dfnbox}{CMAC}{}
    Based on symmetric encryption using CBC mode
\end{dfnbox}


\begin{dfnbox}{UMAC}{}
    Based on universal hashing; pick a hash function based on the key, then encrypt the digest
\end{dfnbox}

Again, don't reuse the same key for encryption and decryption

\begin{codebox}{Simple HMAC in C\#}{}{}
    \begin{amzcode}{csharp}
using System.Security.Cryptography;
using System.Text;

var message = "Hello World!";
var plaintext = Encoding.ASCII.GetBytes(message);

var digest = SHA256.HashData(plaintext);
var digest2 = SHA256.HashData(plaintext);

// Verify the two digests are the same
digest.SequenceEqual(digest2)

var receivedtext = "Gello World!";
var key = RandomNumberGenerator.GetBytes(512);
var calculatedMAC = HMACSHA256.HashData(key, plaintext);
var receivedMAC = HMACSHA256.HashData(key, receivedtext);

// This will be false
calculatedMAC.SequenceEqual(receivedMAC);
    \end{amzcode}
\end{codebox}

\chapter{User Authentication}

\dfntxt{Authentication} is the process of verifying an identity is legitimate by some supporting evidence. In contrast, \dfntxt{identification} establishes an identity using contextual information, not necessarily having an explicit identity asserted.

\section{Passwords}

\begin{dfnbox}{Username, Password}{}
    A \dfntxt{password} is a piece of secret information, typically a string of easily-typed characters, that is used to authenticate a user.
\end{dfnbox}


Passwords usually have an associated account with a username, public or secret. We are more concerned with the actual bits of the password, not necessarily the characters themselves. As such, we need to have a deterministic way of converting characters to bits, whether it be ASCII or UTF-8.

\begin{tabularx}{\linewidth}{| X | X |}
    \hline
    Advantages of passwords:
    \begin{itemize}[noitemsep,leftmargin=*]
        \item Simple and easy to learn
        \item Free for users
        \item No physical load to carry
        \item Usually easy to recover lost access
        \item Easily delegated (e.g. sharing Netflix passwords)
    \end{itemize}
    &
    Disadvantages of passwords:
    \begin{itemize}[noitemsep,leftmargin=*]
        \item Hard to create random passwords (theoretical space is large, but practical space is small)
        \item Hard to remember good passwords
        \item Users often reuse passwords
    \end{itemize}
    \\ \hline
\end{tabularx}

To address the problem that the practical space of passwords is relatively small, some systems use \dfntxt{system-assigned passwords} that maximize the space of passwords.

\begin{dfnbox}{Password Composition Policies}{}
    A \dfntxt{password composition policy} specifies requirements about creating a password, such as minimum and maximum password length, or character requirements and restrictions.
\end{dfnbox}

Although intended to improve password strength, these composition policies often backfire. It makes a lot of users recycle the same passwords. Similarly, forced password changes often backfire as most users, tech-savvy or not, will increment their password like ``hello1'', ``hello2''. This predictable pattern allows attackers to easily guess passwords whenever the next forced change happens.

\begin{dfnbox}{Passkey}{}
    A \dfntxt{passkey} is a cryptographic key derived from a password.
\end{dfnbox}

PBKDF2 is a common function. Modern algorithms like Argon2id can also be used.

\section{Password Authentication}

Password authentication can be defeated by techniques such as:
\begin{enumerate}[noitemsep]
    \item \dfntxt{Online password guessing:} guesses are sent to the legitimate server
    \item \dfntxt{Offline password guessing:} guesses are checked locally, usually accompanied by the password database itself
    \item \dfntxt{Password capture:} attacker directly intercepts or observes the password (e.g. key logging, phishing, or simply looking over someone's shoulder as they type the password)
    \item \dfntxt{Password interface bypass:} completely bypass the password system
    \item \dfntxt{Defeating recovery mechanisms:} use account recovery methods to gain access to accounts
\end{enumerate}

\begin{exbox}{Simplest (and worst) password authentication}{}
    Registration:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to the website
        \item Website stores the username and password in plaintext
    \end{itemize}
    Authentication:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to the website
        \item Website compares the sent values with the stored values
    \end{itemize}
\end{exbox}

Some of the major flaws include:
\begin{itemize}[noitemsep]
    \item Data can be intercepted when sending to the server; need to encrypt communication between user and server
    \item \dfntxt{Phishing:} attacker tricks user into giving the attacker their info; hard to mitigate, could use password managers or hardware security tokens
    \item Online password guessing; have to rate limit authentication attempts, can also require strong passwords
    \item Password database theft
\end{itemize}

\begin{exbox}{Simple but better password authentication}{}
    Registration:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to the website
        \item Website hashes the password, then stores the info
    \end{itemize}
    Authentication:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to the website
        \item Website hashes the received password and compares the calculated hash
    \end{itemize}
\end{exbox}

This is much better, but there are still some pretty serious flaws:
\begin{itemize}[noitemsep]
    \item \dfntxt{Offline guessing:} if an attacker steals the database, then they can guess passwords until it matches one of the hashed passwords with no rate limit.
    \item \dfntxt{Rainbow Table Attack:} someone can simply create a table of password hashes for common passwords
\end{itemize}

\begin{exbox}{Salted Hashing}{}
    Registration:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to website
        \item Website generates some random bytes called a \dfntxt{salt}
        \item Website hashes the received password concatenated with the salt (similar to padding)
        \item Website stores username, and salt in plaintext as well as the hashed password
    \end{itemize}
    Authentication:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to website
        \item Website retrieves the salt for the username
        \item Website hashes the received password along with salt
        \item Website compares the calculated hash with the stored hash
    \end{itemize}
\end{exbox}

This defeats generalized rainbow table attacks. In extreme situations, a motivated adversary can steal the database and use the salt to create a specialized rainbow table targeted against one person.

We can add more features for stronger security, such as:
\begin{itemize}[noitemsep]
    \item \dfntxt{Iterated Hashing:} Repeatedly hash the salt and password a large number of times; slows down brute force guessing; has minimal impact on legitimate authentications
    \item \dfntxt{Specialized Functions:} Use memory-intense and cache-intense functions; makes it hard to accelerate, reducing password guessing rate significantly (e.g. Argon2id, bcrypt/scrypt)
    \item \dfntxt{Keyed Hash Function:} Use a hash function that requires a cryptographic key (e.g. HMAC); if key isn't stolen, it will be impossible to conduct offline guessing
\end{itemize}

\begin{codebox}{Passwords with Salted Hashing in C\#}{}{}
    \begin{amzcode}{csharp}
using System.Security.Cryptography;
using System.Text;

var password = "hello";
var passwordBytes = Encoding.ASCII.GetBytes(password);

var salt = RandomNumberGenerator.GetBytes(32);

// hash for 100000 iterations
var hash = Rfc2898DeriveBytes.Pbkdf2(password, salt, 100000, HashAlgorithmName.SHA256, 32);

using BCrypt.Net;

// Returns a crazy string
var temp = BCrypt.Net.BCrypt.HashPassword(password);

// Should return true
BCrypt.Net.Bcrypt.Verify(password, temp);
    \end{amzcode}
\end{codebox}

\section{Account Recovery}

When a user forgets their password or their account gets compromised, it's important that the user can still recover that account. It's also important to not let the account recovery method be easier for an adversary than password authentication. Security is only as strong as its weakest link.

\begin{dfnbox}{Password Recovery, Account Recovery}{}
    \dfntxt{Password recovery} retrieves a user's lost password. \dfntxt{Account recovery} lets a user regain access to their account, requiring a password reset.
\end{dfnbox}

Password recovery is a sign that the server is storing passwords in plaintext, or they are simply encrypting them without hashing. Either way, it's terrible security practice, and is a sign that the maintainers of the website have no idea how to implement good security.

In practice, account recovery should be the only recovery method available. Some popular methods include:
\begin{itemize}[noitemsep]
    \item \dfntxt{Email-Based Recovery:} Send a link to the email account; makes accounts only as strong as the email
    \item \dfntxt{SMS-based recovery:} similar to email-based recovery; prone to sim swapping
    \item \dfntxt{Security Questions:} in practice, it's easy for attacker to learn answers to these questions
\end{itemize}

\begin{dfnbox}{Single Sign-On (SSO)}{}
    \dfntxt{Single Sign-On} lets a single identity provider handle user authentication for multiple services.
\end{dfnbox}

For example, you have probably logged into websites using your Google account. While SSO creates a single point of failure, it can be argued it's not that bad because most users already reuse the same password for multiple sites. Hence, many services let identity providers handle authentication. It's easier for the user (who doesn't have to create as many accounts), and most identity providers have top-class security.

In the Single Sign-On, there are three parties: the user, relying party, and identifying party. When trying to authenticate with the relying party, we first request an authentication token from the identifying party. We then send that token to the relying party, who verifies the token is correct by asking the identifying party.

\begin{dfnbox}{CAPTCHA}{}
    \dfntxt{CAPTCHA} refers to any online test used to differentiate human and computer entities. It's a loose acronym of ``completely automated public Turing test to tell computers and humans apart''.
\end{dfnbox}

A popular and modern approach to CAPTCHA is \dfntxt{reCAPTCHA}. It measures behavioral patterns such as interactions with the website as well as other metrics like IP address to determine if you're a human. If it's not sure, it makes you do the traffic light clicking thing. If it really thinks you're a robot, it makes you do those fading traffic light clicking things.


\section{Authentication Factors}
Authentication factors are used to verify you are who you say you are. They rely on one or more of the following:
\begin{itemize}[noitemsep]
    \item something you \dfntxt{know} (like a secret PIN or password)
    \item something you \dfntxt{have} (like a phone or credit card)
    \item something you \dfntxt{are} (fingerprints, behaviors)
\end{itemize}

\begin{dfnbox}{Multi-Factor Authentication}{}
    \dfntxt{Single factor authentication} authenticates users using only one factor. \dfntxt{Two-factor authentication (2FA)} authenticates using two distinct factors, most commonly a password and something you have. \dfntxt{Three-factor authentication (3FA)} is the most secure but usually not practical.
\end{dfnbox}

2FA substantially increases the security of accounts, but it needs to be carefully implemented to avoid usability issues.

Something you have:
\begin{itemize}[noitemsep]
    \item In your possession, trivial to authenticate
    \item Nothing to remember
    \item If you don't have the item, you can't authenticate
    \item If someone steals the item, you have immediate access
    \item If you lose item, account recovery is difficult
\end{itemize}

We can use the thing you have by sending that thing a secret value.
\begin{itemize}[noitemsep]
    \item Service sends a secret value to your device (one-time password)
    \item You authenticate by entering the secret value
    \item Problem: easy to phish
\end{itemize}

Alternatively, we can just have some way to synchronize the secret value generation, so we only need to send a secret once.
\begin{itemize}[noitemsep]
    \item Service sends you a secret during account registration
    \item Secret is stored on your device
    \item The secret is used to generate the same one-time password on both the server and dev
    \item Authenticate by entering the value generated by your device.
    \item Problem: still easy to phish, but attacker would only have a one-time window
\end{itemize}

We could use some dedicated device for this.
\begin{itemize}[noitemsep]
    \item Dedicated device generates a public-key private-key pair
    \item Public key is sent to service during registration
    \item Device uses its private key to sign authentication requests
    \item Can be designed to avoid phishing and require presence
    \item Usually comes with some backup codes in case the device is broken; those can be prone to phishing
\end{itemize}

When it comes to something you are:
\begin{itemize}[noitemsep]
    \item Nothing to remember
    \item Nothing to carry
    \item Difficult to steal
    \item Usually requires specialized hardware; bad hardware is prone to error and/or security issues
    \item If you lose your biometric, how do you recover your account?
    \item Sharing biometrics is risky in the first place
\end{itemize}

Some examples include:
\begin{itemize}[noitemsep]
    \item Fingerprints -- lots of poorly designed hardware prone to fingerprint lifting or forging
    \item Facial Recognition -- similar looking people like siblings can log in too
    \item Iris Recognition -- specialized hardware costs a lot
    \item Brainwave Recognition --
    \item Behavior Biometrics -- e.g reCAPTCHA
    \item Walking Cadence -- how you walk
    \item Travel Patterns -- used by gov't to identify suspicious people
\end{itemize}

When using biometrics for an app, it's usually not being sent to the server. Instead, the OS will only decrypt shared secret after authenticating using biometrics.

\begin{notebox}{}
    When authentication with biometrics like fingerprints, we aren't actually sending biometric info to the server. When logging in, the website and local device create a secret passphrase, and the local device only sends the passphrase to the website when the local device verifies your biometric. This is not a form of 2FA. From the website's perspective, there's only a single factor of authentication.
\end{notebox}

\chapter{OS Security}



\section{Reference Monitor}

\begin{dfnbox}{Subject, Action, Object}{}
    A \dfntxt{subject} is any entity (such as a user or process) trying to take some \dfntxt{action} such as read, write, execute, start, shutdown, etc. The \dfntxt{object} receives the action, such as some memory, files, services, or devices.
\end{dfnbox}

The subject is usually authenticated, but not necessarily. We can sometimes have an unknown subject.

\begin{dfnbox}{Policy, Reference Monitor}{}
    \dfntxt{Policies} define what is allowed, usually parameterized by subject, action, and object. \dfntxt{Reference monitors} enforce a policy by checking actions, allowing subjects to execute an action if it conforms with the policy.
\end{dfnbox}

Whenever a subject tries to make an action, the reference monitor gets to decide whether it should be allowed. The reference monitor has to require:

\begin{itemize}
    \item \dfntxt{Complete Mediation:} all actions must go through the reference monitor (also ensures complete logs)
    \item \dfntxt{Tamper-proof:} users can't just manipulate the reference monitor; also includes tamper-proof logs
    \item \dfntxt{Verifiable:} reference monitor must be easily analyzable (means its source code has to be small!)
    \item \dfntxt{Reliable Authentication and/or Authorization:} authentication for subject identfication; authorization for bearer tokens
\end{itemize}

\begin{dfnbox}{Permission, Capability List}{}
    A \dfntxt{permission} is a pair of (action, object). The list of all permissions associated with a subject can be called a \dfntxt{capability list}.
\end{dfnbox}

\begin{dfnbox}{Capability-Based Access Control, Bearer Token}{}
    \dfntxt{Capability-Based Access Control} reference monitor issues \dfntxt{bearer tokens} which let anyone with the token take specific action(s).
\end{dfnbox}

An example of a bearer token would be the link-sharing system on Google Docs. The document creator can easily delegate links which allow those with the link to view or edit our document. Another example would be API tokens.

\begin{dfnbox}{Access Control List (ACL)}{}
    The \dfntxt{access control list} is the set of (subject, action) pairs associated with an object.
\end{dfnbox}

Some other popular access control paradigms include:
\begin{itemize}
    \item \dfntxt{Role-based access control (RBAC):} associates permissions with certain groups of users rather than users themselves.
    \item \dfntxt{Attribute-based access control (ABAC):} incorporates contextual information to access control decisions (e.g. subject's behavioral patterns, current location; action's time of day, current threat level; object's location on network, creation date, size)
    \item \dfntxt{Cryptographic access control:} use cryptography for access control without a reference monitor
\end{itemize}

\section{Memory Protection}
We care about memory protection because of concurrent execution: multiple users and multiple processes at the same time. We need to isolate resources from each process and user.

\begin{dfnbox}{Virtual Memory}{}
    \dfntxt{Virtual memory} is an idealized abstraction of memory, mapping virtual addresses to physical memory addresses.
\end{dfnbox}

In virtual memory, the OS kernel acts as a reference monitor for memory, mediating access to system memory. The kernel allocates memory by giving processes virtual addresses that map to physical ones. The kernel also limits who can access what memory, preventing users/processes from accessing other memory. It also protects OS memory and provides safe mechanisms for shared memory access.

\begin{dfnbox}{Kenel Memory Segmentation, Memory Segments}{}
    The kernel divides memory into \dfntxt{memory segments}---contiguous regions of memory. Each segment is assigned one or more modes: read, write, execute, mode, fault.
\end{dfnbox}

The latter two modes are used by the OS for specific uses. The kernel sets default modes when allocating memory. Memory segments with code is marked as executable. Memory segments with the heap and stack are marked as readable and writable, not executable (prevents arbitrary code execution). In accordance with the principle of least privilege, the process can further restrict its own permissions.

\section{File System Access Control}

\begin{dfnbox}{File system}{}
    A \dfntxt{file system} is a hierarchical structuring of directories and folders. It maintains per-file meta-data, including permissions.
\end{dfnbox}

In the context of file systems:
\begin{itemize}[noitemsep]
    \item The \dfntxt{subjects} are users, groups or processes (identified by some user id, group id, or process id).
    \item The \dfntxt{actions} are read/write/execute, modify metadata, etc.
    \item The \dfntxt{objects} are files, directories, links, and devices.
\end{itemize}

% The possible subjects in file system access control include:
% \begin{itemize}[noitemsep]
%     \item Users are identified by a user id (UID)
%     \item Groups are identified by a group id (GID) (for role-based access control)
%     \item Processes are identified by a process id (PID)
% \end{itemize}

We can classify file system actions by three distinct categories:
\begin{enumerate}
    \item \dfntxt{Basic actions} like read, write, and execution of files.
    \item \dfntxt{Special actions} like:
    \begin{itemize}[noitemsep]
        \item Execute a binary as the owning user (e.g. sudo)
        \item Execute as the primary group of the owning user
        \item Set ``sticky bit'' (disables changing name or file deletion)
    \end{itemize}
    \item \dfntxt{Advanced actions} like:
    \begin{itemize}[noitemsep]
        \item Take ownership of a file
        \item Change permissions
        \item Write attributes
        \item Inspect or modify memory (debugging permission)
    \end{itemize}
\end{enumerate}

% Actions involving the file system include basic ones like read, write, execute, and list folder contents. Some special actions include:

% Advanced actions include:


\begin{exbox}{Linux Access Control (user-group-other or UGO)}{}
    Linux uses the \dfntxt{user-group-others} (UGO) permission model which is a highly condensed ACL. This:
    \begin{itemize}[noitemsep]
        \item limits subjects to either the owning user, primary group of the owning user, and everyone else, and
        \item limits actions to read, write, execute, and special permissions (directory travel is controlled by read; modify and write are considered the same)
    \end{itemize}
    When determining permissions for actions, Linux checks the following in order, letting the action happen if any one of these is true:
    \begin{enumerate}[noitemsep]
        \item Is the subject the owning user?
        \item Is the subject a member of the owning group?
        \item Do the file's default permissions allow this action?
    \end{enumerate}
    Note that permissions are not inherited (i.e. every object has its own permission list). Also, it's possible to let a subject access an object inside a directory that the subject cannot access (i.e. they can't discover the path, but can access the object if they know the path).

    In contrast to traditional ACLs which specifies every allowed subject action pairs associated with an object, UGO only cares about one user, one group, and lumps everyone else into ``other''.
\end{exbox}

\begin{exbox}{Windows Access Control}{}
    Windows follows role-based access control (RBAC) with the roles being groups. When an object is created, it inherits the permissions of the parent folder.
\end{exbox}

\section{Additional Topics}

\begin{dfnbox}{Hidden File}{}
    A \dfntxt{hidden file} has an attribute that indicates files which should be ignored when listing the contents of a directory.
\end{dfnbox}

On Linux, this is done be prepending a file name with a period. On Windows, it's part of the file metadata. This does not change any permissions regarding the file, so it should never be used as a security measure.

\begin{dfnbox}{inode}{}
    An \dfntxt{inode} is a chunk of data that contains file name, metadata, and where the actual data is stored on the hard drive.
\end{dfnbox}

In the UNIX file system, filenames are just a reference to an inode. The inode is only deleted when all filename references to it are deleted.

\begin{dfnbox}{File System Links}{}
    \dfntxt{File system links} are data that directly associate a filename with an inode. It allows for more than one file to refer to the same data on the hard drive.
    \begin{itemize}[noitemsep]
        \item A \dfntxt{hard link} is an additional filename reference to an inode, managed by the underlying file system.
        \item A \dfntxt{symbolic link} (or symlink) is a text file that contains a single filename. The OS provides file utilities that will read and handle symlinks. It does not reference the inode, so it does not prevent the inode from being deleted.
    \end{itemize}
\end{dfnbox}

\begin{dfnbox}{chroot jail}{}
    In UNIX, the \texttt{chroot} command takes a specified directory and treats it as the root directory, thereby restricting file system access. This is referred to as a \dfntxt{chroot jail}.
\end{dfnbox}

The chroot jail is in-line with the principle of least privilege as it limits the impact of compromise. Nowadays, this is largely replaced by sandboxing and containerized app deployments.


\texttt{chroot}: restricts file system access
\begin{itemize}
    \item  treats the specified directory as the root directory \texttt{/}
    \item \dfntxt{chroot jail}: \todo{wht is this}
\end{itemize}

\begin{dfnbox}{Discretionary Access Control, Mandatory Access Control}{}
    In \dfntxt{discretionary access control}, users are responsible for assigning access control rules for their files. In \dfntxt{mandatory access control}, a policy administrator sets all the access control rules.
\end{dfnbox}

Mandatory access control usually relies on role-based access control (RBAC).

\begin{dfnbox}{Security-Enhanced Linux (SELinux)}{}
    \dfntxt{Security-Enhanced Linux} is a kernel module found in most Linux distributions, supporting mandatory security policies and mandatory access control. It uses attribute-based access control (ABAC) for applications, processes, and files.
\end{dfnbox}

As a side effect, SELinux is often the cause of many issues when running software on Linux. \textbf{Never} disable SELinux; only ever reconfigure SELinux to make it work with your software.

\chapter{Software Security}

\section{TOCTOU Race}

\begin{dfnbox}{Time-of-check (TOC), Time-of-use (TOU)}{}
    \dfntxt{Time-of-check (TOC)} is when a reference monitor checks the permission for an action. \dfntxt{Time-of-use (TOU)} is when a reference monitor uses the previous check to allow an action.
\end{dfnbox}

A common assumption is that the permission condition being checked does not change from the time-of-check to time-of-use. However, in multi-threaded systems where processes can be interrupted or temporarily suspended, permission conditions can change between TOC and TOU (e.g. file permissions or arguments passed to routines).

\begin{dfnbox}{Race Condition, TOCTOU Race}{}
    A \dfntxt{race condition} is a software vulnerability that occurs when the timing or sequence of events affects a program's behavior. A \dfntxt{TOCTOU race} is a specific race condition where the state of a resource or condition changes between time-of-check and time-of-use.
\end{dfnbox}


File operations are especially vulnerable to TOCTOU race because they rely on an external device. This means the process has to wait on I/O to and from the device. As explained by Chat-GPT:

\begin{notebox}
    File operations often require interactions with external devices, such as a hard disk, to read or write data. These interactions can take a non-negligible amount of time and can lead to vulnerabilities related to TOCTOU race conditions. Specifically, if a process checks the state of a file, such as its existence or permissions, and then performs an operation on it, such as reading or writing data, it can be vulnerable to race conditions if the state of the file changes during the interval between the check and the operation. This can occur because the external device may be shared by multiple processes or may have a time delay due to its physical nature. As a result, if the process does not properly synchronize or control access to the file, it may lead to unexpected or unintended behavior. Therefore, it is important to implement appropriate locking or synchronization mechanisms when accessing files in a concurrent or multi-process environment to prevent TOCTOU race conditions.
\end{notebox}

% TOCTOU Race:
% \begin{itemize}
%     \item Time-of-check (TOC): when you check whether an action is allowed
%     \item Time-of-use (TOU): when you execute the action
%     \item TOCTOU race: potential that action becomes disallowed between checking and executing the action; often caused by multi-threading allowing concurrent execution
% \end{itemize}

% \begin{itemize}
%     \item File-based TOCTOU
%     \item TOC: Check if file exists; check if necessary permissions
%     \item TOU: create/access file
%     \item Although code is written in sequence, not guaranteed to run in sequence (OS can interrupt our process)
% \end{itemize}

Some common ways of fixing TOCTOU race conditions:
\begin{itemize}
    \item Thread-locking: ensuring only one thread runs a procedure at a time
    \item Use calls that do both the check and action in one call; guarantees OS will run it right
    \item \todo{slides}
\end{itemize}

\section{Integer-Based Vulnerabilities}

C is ``weakly-typed'', meaning it will implicitly typecast between different integral types. It won't throw exceptions for arithmetic errors. Other languages are more likely to check for these issues and throw exceptions when they happen.

Lots of the issues come from the choice to use fixed-precision data types.
\begin{itemize}
    \item \dfntxt{Overflow:} the result of an arithmetic operation is too large to store; excess bits get truncated (usually the most-significant bits get truncated)
    \item \dfntxt{Underflow:} the result of an arithmetic operation is too small to store; again, excess bits gets truncated
\end{itemize}

Casting Issues:
\begin{itemize}
    \item When casting between signed and unsigned numbers, the underlying bits don't change
    \item When casting to smaller data types, bits get truncated
    \item Sign problems: compare signed and unsigned variables causes both to cast to unsigned numbers; sometimes treats negative numbers are being larger than positive numbers
\end{itemize}

C Type Coercion:
\begin{itemize}
    \item If any operand is unsigned, then all operands are treated as unsigned
    \item The size of the resulting data type is either the size of an integer or the size of the biggest operand
    \item \todo{slides}
\end{itemize}

\section{Memory}

When an x86-64 system loads a binary, it stores some things into memory:
\begin{itemize}
    \item \dfntxt{Text:} Machine code for the executing binary
    \item \dfntxt{Shared libraries:} machine code for common libraries; only loaded into memory once to save space (shared by all processes); read and execute permissions
    \item \dfntxt{Data:} statically allocated data like global and static variables, as well as string constants; read and write permissions
    \item \dfntxt{Stack:} stack frames and associated data; 8MB by default; read and write permissions
    \item \dfntxt{Heap:} dynamically allocated objects (e.g. malloc'ed data); read and write permissions
\end{itemize}

\begin{dfnbox}{Stack}{}
    The \dfntxt{stack} is a contiguous piece of memory allocated to a program when it runs. Since it's a fixed size, it starts from the highest address and ``grows'' towards the lower address.
\end{dfnbox}

A CPU register tracks the memory address of the top of the stack (sometimes called a stack pointer). Each function call allocates some memory from the stack called a \dfntxt{stack frame}. It stores the data needed to execute the function such as:
\begin{itemize}
    \item the seventh or higher argument
    \item variadic arguments (from a function that takes a variable number of arguments)
    \item local variables
    \item data needed to return to the calling function such as the return address and stored CPU state (e.g. register before the fuction call)
\end{itemize}

\begin{dfnbox}{Buffer, Buffer Overflow}{}
    A \dfntxt{buffer} is an array used to read in data. It's usually a fixed size but can be dynamically allocated. A \dfntxt{buffer overflow} occurs when we write past the end of the buffer.
\end{dfnbox}

\begin{notebox}
    Many compilers will give a procedure's stack frame some extra unused bytes or padding to prevent buffer overflows reaching important memory like the return address.
\end{notebox}

Effects of buffer overflow can widely vary, including:
\begin{itemize}
    \item nothing: overflow into the padding or some unused data
    \item minor issues: overwriting the return address to jump to another benign part of the program, or overwrites data that is still used but does not significantly modify behavior
    \item serious issues: changing the return address to an invalid address (SEGFAULT), or change program data to modify the program's behavior
    \item catastrophic issues: change return address to jump to attacker control code; can cause full machine compromise
\end{itemize}

Possible places for an attacker to inject malicious code include the stack (e.g. buffer), shared libraries (e.g. DLLs), local/global variables, environment variables, heap, and command-line arguments (\texttt{argv}). Attacking the stack is most common because the return address is right there.

\section{Buffer Overflow Defenses}

\begin{tabularx}{\linewidth}{| X | X |} \hline
    \textbf{Technique} & \textbf{Limitations} \\ \hline

    Mark the stack and heap as non-executable &
    \begin{itemize}[leftmargin=*]
        \item Loss of functionality like reflection
        \item Can be circumvented by using code from other parts of memory (called return-oriented programming)
        \item Code snippets found in \texttt{libc} are Turing complete!
    \end{itemize} \\ \hline

    \dfntxt{Stack canary:} have some random value between the return address and local variables that changes every function call. If it unexpectedly changed, then we know a buffer overflow happened. &
    \begin{itemize}[leftmargin=*]
        \item Can be worked around if the canary can be learned
    \end{itemize} \\ \hline

    \dfntxt{ASLR:} randomize the location of the stack &
    \begin{itemize}[leftmargin=*]
        \item Can be worked around using a NOP sled
        \item Other vulnerabilties can be used can be used to locate the stack
    \end{itemize} \\ \hline

    Simply use the safe C library functions (e.g. \texttt{strlcpy} instead of \texttt{strcpy}) &
    \begin{itemize}[leftmargin=*]
        \item Requires competency from the developer to know about these functions and use them correctly
        \item Easy to make a mistake and allow attacks to still happen
    \end{itemize} \\ \hline

    Just use another language that does bounds-checking on buffers, pointers, and type casting. These checks can happen at runtime or compile time. &
    \begin{itemize}[leftmargin=*]
        \item This can still be circumvented in rare edge cases
    \end{itemize} \\ \hline
\end{tabularx}

% Firstly, we could mark the stack and heap as non-executable, preventing code injection attacks in the stack. This could cause a loss of functionality like reflection. This defense can be circumvented by using code snippets from other parts of memory, referred to as return-oriented programming. (code snippets found in \texttt{libc} are Turing complete!)

% \begin{dfnbox}{Stack Canary}{}
% Some architectures implement a \dfntxt{stack canary}---a memory address squished between the return address and local variables. It is set to a random value for each function call, and the canary is checked before jumping to the return address.
% \end{dfnbox}

% The stack canary is an application of defense in depth. This can be worked around if the canary can be learned. This would require finding and exploiting a vulnerability to read the stack.

% \begin{dfnbox}{Address Space Layout Randomization (ASLR)}{}
%     \dfntxt{ASLR} randomizes the location of the stack.
% \end{dfnbox}

% Now, if the attacker uploads a malicious payload to the stack, they don't know what to change the return address to. This again is an application of defense in depth. An attacker would have to find and exploit a vulnerability to read the stack. It can be worked around using a NOP sled. In addition, there are other vulnerabilities to let us know where the stack is.

% We could simply \textbf{use the appropriate C library functions}. Many default C functions don't provide bounds checking for the sake of efficiency. There are equivalent functions that provide bounds checking. It does require competency on the developers' part, so it's still easy to make a mistake and allow an attack to still happen.

% We could just develop in other languages that perform bounds checking for the developer. These checks may happen at runtime or compile time. This can still be circumvented in some edge cases not anticipated by the language designers.

Ultimately, there is no absolute defense for buffer overflows. The best approach is to simply apply defense in depth---use as many techniques as possible to deter attacks.

\section{Privilege Escalation}

Why do we care about vulnerabilities? An attacker's permissions are initially quite limited. Most often, an attacker starts with no direct access to a system, and thus must access it through public interfaces. The services an attacker interacts with often have greater permissions. If an attacker can compromise the service, they can acquire that service's permissions.

Most of the time, these attacks only result in minor privilege escalation. Attackers will use privilege escalation and pivot to attacking another target with greater permissions. This involves a lot of \dfntxt{lateral movement}, slowly moving throughout an organization's resources until they reach their desired target. This may take months or even years.

\section{Malicious Software}

There are several types of software:
\begin{itemize}[noitemsep]
    \item \dfntxt{Legitimate software:} software that is designed for legitimate use
    \item \dfntxt{Harmful software:} software that is designed for legitimate use, but can cause unintentional harm due to poor design or implementation
    \item \dfntxt{Malicious software:} software designed to cause harm
    \item \dfntxt{Potentially Unwanted Software (PUS):} software bundled with other software; usually annoying or unwanted, but not necessarily harmful
\end{itemize}

How does malware get on computers?
\begin{itemize}[noitemsep]
    \item \dfntxt{Phishing:} tricking users to use harmful software
    \item \dfntxt{Repackaged software:} a legitimate program bundled with some malware; especially common in software piracy
    \item \dfntxt{Drive-by download:} non-consensual downloads from exploits in web browser, usually a result of dynamic content
    \item \dfntxt{Self-propagation:} once on a machine, malware can search for other ways to spread like through the local network or email
\end{itemize}

When describing the structure of malware, we focus on four distinct attributes:
\begin{enumerate}[noitemsep]
    \item \dfntxt{Dormancy period:} the time between the malware being on the machine and its first run
    \item \dfntxt{Propagation strategy:} how the malware spreads to other users and machines
    \item \dfntxt{Trigger condition:} what controls when the payload is executed (how long the malware waits to take effect)
    \item \dfntxt{Payload:} what does the malware actually do?
\end{enumerate}

\begin{dfnbox}{Computer Virus}{}
    A \dfntxt{computer virus} is malware that can infect other programs or files by modifying them to include a possibly mutated copy of itself.
\end{dfnbox}

Viruses were the first type of malicious software. Most of the early viruses were actually benign---early hackers were just goofing around. Now, most viruses are designed with the specific intent to cause harm.

\begin{enumerate}[noitemsep]
    \item Dormancy period: dormant until its infected executable runs
    \item Propagation strategy: propagates by tricking users into downloading and running the virus; often focused on social engineering
    \item Trigger condition: often triggers immediately, but can be delayed to avoid detection
    \item Payload: functionality of the actual malware; often compromises existing software, services, and files; impacts can vary drastically
\end{enumerate}

\begin{dfnbox}{Computer Worm}{}
    A \dfntxt{computer worm} is malware that can propagate on its own, usually through the network.
\end{dfnbox}

\begin{enumerate}
    \item Dormancy period: executes immediately
    \item Propagation strategy: automatically and continuously attacks other systems; spreads between machines on the same computer network
    \item Trigger condition: same as a computer virus
    \item Payload: varies greatly
\end{enumerate}

More specifically, worms automatically scan the network for vulnerable machines. When they find one, they will exploit a vulnerability on that machine and replicate the worm. The machine then joins in on the process of finding new vulnerable machines on the network.

Worms have two goals which are often at odds with each other. First, the worm wants to replicate as fast and far as possible to make it harder to remove them. However, the worm also wants to stay undetected.

Techniques for spreading include:
\begin{itemize}
    \item Hit-list scanning: before deploying the malware, the attacker predetermines a set of potentially vulnerable targets, or select servers to avoid servers where attacks could be correlated and detected
    \item Internet-scale hit lists: large hit list of every server on the internet; not particularly stealthy, but very fast and wide-reaching
    \item Permutation scanning: every instance of the worm scans random points in the address space; if it detects an infected machine, choose a new random point; avoids localized detection
\end{itemize}

\begin{dfnbox}{Trojan Horse}{}
    A \dfntxt{trojan horse} is a virus that pretends to be legitimate software.
\end{dfnbox}

This can be fully malicious software that pretends to be legitimate software, or legitimate software that has an additional malicious payload. Its malicious functionality may be immediately apparent, or may take some time to notice. Trojan horses are common in piracy and pornography software.

\begin{dfnbox}{Backdoor}{}
    A \dfntxt{backdoor} is software that allows an adversary to access a machine while bypassing authentication.
\end{dfnbox}

Reverse shell and remote desktop tools are common examples. Often, attackers use tools that are legitimate, but install socially engineer the user to install it.

\begin{dfnbox}{Keylogger}{}
    A \dfntxt{keylogger} is a program that hooks into the operating system API for getting keyboard events.
\end{dfnbox}

With a keylogger, an  attacker can steal sensitive information like passwords or credit card numbers. Also applicable to other I/O devices like the mouse and monitor.

\section{Detecting Viruses}

\begin{dfnbox}{Malware Signature, Behavioral Signature}{}
    A \dfntxt{malware signature} is a sequence of bytes known to be malicious. A \dfntxt{behavioral signature} refers to a sequence of actions used to identify malware.
\end{dfnbox}

These signatures are especially helpful in identifying known malware. However, they are limited in incurring false positives, viruses using previously unknown code or behaviors (zero-day), attackers can create code to avoid detection.

Malware signatures
\begin{itemize}
    \item Byte sequences known to be malicious
    \item Search binaries for these signatures
\end{itemize}

Behavioral signatures
\begin{itemize}
    \item Sequence of actions are known to be malicious
    \item Watch binaries as thy execute to detect these sequences of actions; can test binaries automatically in a VM when downloaded
    \item Related to intrusion detection
\end{itemize}



Preventing viruses:
\begin{itemize}
    \item Integrity-checking: create a whitelist of allowed software binary hashes; more effective than signatures, but it's easy to block legitimate software
    \item Code signing: allow developers to digitally sign their exectuables; check that a binary is signed by a trusted developer; more flexible type of integrity checking
\end{itemize}

The most common type of malware detection is signature detection. A common way to circumvent this is by encrypting the payload, prepended with some code that will decrypt it whenever it runs.
\begin{itemize}
    \item \dfntxt{Encrypted payload:} we encrypt the actual payload, and bundle a decryptor that that decrypts the payload when run
    \item \dfntxt{Polymorphic encrypted payloads:} we use the same encryption, but the virus changes its decryptor for each infection using a \dfntxt{mutation engine}. More advanced, it could use a compiler to create new decryptor implementations on-the-fly.
    \item \dfntxt{External decryption key:} Same as above, but the key is stored externally, not in the binary
    \item \dfntxt{Metamorphic Viruses:} no encryption is used, but the entire payload is recompiled with same functionality but different machine code.
\end{itemize}

\begin{dfnbox}{Rootkit}{}
    A \dfntxt{rootkit} replaces part of the kernel's functionality, able to run as root and side-step the kernel's reference monitors.
\end{dfnbox}

This means rootkits have arbitrary access to memory, files, devices, and the network. This can be very hard to detect, as the rootkit could just overwrite the functionality used to scan for the rootkit. This often means the only way to remove it is to completely reinstall the machine.

\begin{itemize}
    \item \dfntxt{System Call Hijacking:} completely replace a legitimate function call
    \item \dfntxt{Inline Hooking:} add a malicious payload to a legitimate function's precall or postcall methods
\end{itemize}

Installing rootkits:
\begin{itemize}
    \item Superusers can simply install kernel modules
    \item Exploit a vulnerability in the kernel (will already be running with maximum permissions)
    \item Modify bootloader to load a modified kernel
    \item Improper memory handling for the kernel  (page files written to disk, direct memory access)
\end{itemize}

There are legitimate uses for rootkits, including virus scanners, debuggers, anti-cheat, and anti-piracy software.

\todo[inline]{web stuff}

Supplychain attack: Web widgets (third party code running on trusted websites) might get attacked; affecting everyone that uses that widget

Cross-site scripting: \todo{do this}

\begin{dfnbox}{Ransomware}{}
    \dfntxt{Ransomware} holds files or computers for ransom, whether it be deleting or leaking files.
\end{dfnbox}

\begin{itemize}
    \item \dfntxt{Encrypting ransomware:} encrypts all the user's personal files; upon payment, the attacker (hopefully) provides software to decrypt the files
    \item \dfntxt{Non-encrypting ransomware:} Can simply modify access control rules, disable OS functionality,
\end{itemize}

Encrypting ransomware is hard to fix because, if we choose to remove the ransomware before paying, the files are still encrypted. Non-encrypting ransomware is relatively easy to fix. We can just access the files through a different OS, or reinstall the OS without harming the files.

Backups can be used to mitigate ransomware.

\begin{dfnbox}{Botnet}{}
    A \dfntxt{botnet} is a set of compromised networked computer (bots), coordinated by an attacker (the botmaster).
\end{dfnbox}

This greatly increases the attacker's ability to conduct large-scale attacks. It also helps avoid detection, since it's a more distributed attack.

\begin{enumerate}
    \item Infect: attacker seeds the botnet by manually targeting some computers
    \item Connect: after infection, bots connect to command and control server(s) to receive further orders (referred to as a C\& C or C2 server)
    \item Control: the C2 infrastructure sends commands to the bots
    \item Multiply: bots automatically target other machines, attempting to infect them
\end{enumerate}

Botnets are commonly used for:
\begin{itemize}
    \item Distributed denial-of-service (DDoS) attacks
    \item Spamming and phishing emails
    \item Computational power for brute-force attacks, like cracking password databases
    \item Money laundering: use computers to transfer funds
    \item Data theft
    \item Cryptocurrency mining
\end{itemize}

\section{Categorizing Malware}
Objectives:
\begin{itemize}
    \item Damage to the host or its data
    \item Data theft
    \item Direct financial gain
    \item Ongoing surveillance
    \item Spread of malware (lateral movement)
    \item Control of resources
\end{itemize}

\amzindex
\end{document}
