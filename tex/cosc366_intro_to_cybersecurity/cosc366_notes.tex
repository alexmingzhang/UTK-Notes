\documentclass[12pt]{report}

\usepackage[margin=1in]{geometry}
\usepackage[code]{amznotes}
\usepackage{enumitem}

\title{\textbf{Introduction to Cybersecurity}\\
\large UT Knoxville, Spring 2023, COSC 366}
\author{Alex Zhang}

\begin{document}

\maketitle
\tableofcontents

\chapter{Security Concepts and Principles}

\section{Fundamental Goals of Computer Security}

\begin{dfnbox}{Computer Security}{computer-security}
    \dfntxt{Computer security} is the practice of protecting computer-related assets from unauthorized actions, either by preventing such actions or detecting and recovering from them.
\end{dfnbox}

The goal of \nameref{dfn:computer-security} is to help users complete their desired task safely, without short or long term risks.  To do this, we support computer-based services by providing essential security properties.

\begin{dfnbox}{Confidentiality, Integrity, Availablity (CIA)}{cia}
    The \dfntxt{CIA triad} is a pneumonic device that includes three essential security properties:
    \begin{itemize}[noitemsep]
        \item \dfntxt{Confidentiality}: only authorized parties can access data; applies at rest and in motion (data being transmitted)
        \item \dfntxt{Integrity}: data, software or hardware remaining unchanged, except by authorized parties
        \item \dfntxt{Availability}: information, services and computing resources are available for authorized use
    \end{itemize}
\end{dfnbox}

\begin{dfnbox}{Principal, Privilege}{}
    A \dfntxt{principal} is an entity with a given identity, such as a user, service, or system process. A \dfntxt{privilege} defines what a principal can do, such as read/write/execute permissions.
\end{dfnbox}

In addition to the \nameref{dfn:cia}, we also have three security properties relating to principals.
\begin{dfnbox}{Authentication, Authorization, Auditability (Golden Principles)}{}
    The \dfntxt{Golden Principles} are three security properties regarding principals:

    \begin{itemize}[noitemsep]
        \item \dfntxt{Authentication}: assurance that a principal is who they say they are
        \item \dfntxt{Authorization}: proof that an entity has the necessary privilege to take the request action; most commonly done by authenticating a principal, and lookup up its privileges
        \item \dfntxt{Auditability}: ability to identify principals responsible for past actions
    \end{itemize}

\end{dfnbox}

Auditability (or accountability) gives away two key things: who conducted the attack and the methods by which an attack was made.

\begin{dfnbox}{Trustworthy, Trusted}{}
    Something is \dfntxt{trustworthy} if it deserves our confidence.     Something is \dfntxt{trusted} if it has our confidence.

\end{dfnbox}

\begin{dfnbox}{Privacy, Confidentiality}{}
    \dfntxt{Privacy} is a sense of being in control of access that others have to ourselves. It deals exclusively with people. \dfntxt{Confidentiality} is an extension of privacy to also include personally sensitive data.
\end{dfnbox}

\section{Computer security policies and attacks}

\begin{dfnbox}{Asset}{asset}
    An \dfntxt{asset} is a resource we want to protect, such as information, software, hardware, or computing/communications services.
\end{dfnbox}

Note that asset can refer to any tangible or intangible resources.

\begin{dfnbox}{Security Policy}{}
    A \dfntxt{security policy} specifies the design intent of a system's rules and practices (i.e. what the system is supposed to do and not do).
\end{dfnbox}

\begin{dfnbox}{Adversary}{}
    An \dfntxt{adversary} is an entity who wants to violate a security policy to harm an asset.
    \tcblower
    Can also be called ``threat agents'' or ``threat actors''.
\end{dfnbox}

A formal security policy should precisely define each possible system state as either authorized (secure) or unauthorized (non-secure). Non-secure states raise the potential for attacks to happen.

\begin{dfnbox}{Threat}{}
    A \dfntxt{threat} is any combination of circumstances and entities allow harm to assets or cause security violations.
\end{dfnbox}

\begin{dfnbox}{Attack, Attack Vector}{attack}
    An \dfntxt{attack} is a deliberate attempt to cause a security violation. An \dfntxt{attack vector} is the specific methods and steps by which an attack was executed.

\end{dfnbox}

\begin{dfnbox}{Mitigation}{mitigation}
    \dfntxt{Mitigation} describes countermeasures to reduce the chance of a threat being actualized or lessen the cost of a successful attack.
\end{dfnbox}

\nameref{dfn:mitigation} includes operational and management processes, software controls, and other security mechanisms.

\begin{exbox}{House Security Policy}{house}
    Consider this simple security policy for a house: no one is allowed in the house unless accompanied by a family member, and only family members are authorized to take things out of the house.
    \begin{itemize}
        \item The presence of someone who wants to steal an asset from our house is a \textbf{threat}.
        \item An unaccompanied stranger in the house is a \textbf{security violation}.
        \item An unlocked door is a \textbf{vulnerability}.
        \item A stranger entering through the unlocked door and stealing a television is an \textbf{attack}.
        \item Entry through the unlocked door is an \textbf{attack vector}.
    \end{itemize}
\end{exbox}

\section{Risk, risk assessment, and modeling expected losses}

\begin{dfnbox}{Risk}{risk}
    A \dfntxt{risk} is the expected loss of assets due to future attacks.
\end{dfnbox}

There are two ways we assess risk: \dfntxt{quantitative} and \dfntxt{qualitative} risk assessment.
\begin{itemize}
    \item \dfntxt{Quantitative} risk assessment computes numerical estimate of risk
    \item \dfntxt{Qualitative} risk assessment compares risks relative to each other
\end{itemize}

Quantitative risk assessment is more suited for incidents that occur regularly, with historical data and stable statistics to generate probability estimates. However, computer security incidents occur so infrequently that any estimate of probability likely isn't precise. In contrast, qualitative risk assessment is usually more practical. For each asset or asset class, their relevant threats are categorized based on probability of happening and impact if it happened.

Precise estimates of risk are rarely possible in practice, so qualitative risk assessment is usually yields more informed decisions. A popular equation for modeling risk is:
\[ R = T \cdot V \cdot C \]
where:
\begin{itemize}
    \item $T$ is the probability of an attack happening,
    \item $V$ is the probability such a vulnerability exists, and
    \item $C$ is cost of a successful attack, both tangible and intangible costs
\end{itemize}

$C$ can encompass tangible losses like money or intangible losses like reputation. Whatever model we use, we can then model expected losses as such:

In risk assessment, we ask ourselves these questions:
\begin{enumerate}
    \item What assets are most valuable, and what are their values?
    \item What system vulnerabilities exist?
    \item
\end{enumerate}

In answering these questions, it becomes apparant we cannot employ strictly quantitative risk assessment. A popular model for qualitative risk assessment is the \nameref{dfn:dread} model:

\begin{dfnbox}{DREAD}{dread}
    \dfntxt{DREAD} is a method of qualitative risk assessment using a subjective scaled rating system for five attributes.

    \begin{center}\begin{tabular}{r | l | l}
        Attribute & 10 & 1 \\ \hline
        \dfntxt{Damage Potential} & data is extremely sensitive & data is worthless \\
        \dfntxt{Reproducibility} & works every time & works only once \\
        \dfntxt{Exploitability} & anyone can mount an attack & requires a nation state \\
        \dfntxt{Affected Users} & 91-100\% of users & 0\% of users \\
        \dfntxt{Discoverability} & threat is obviously apparent & threat is undetectable
    \end{tabular}\end{center}

    The final DREAD score takes the average of all five attributes.
\end{dfnbox}

A common criticism of \nameref{dfn:dread} is that rating discoverability might reward security through obscurity. Often, people will omit discoverability, or simply assign it the maximum value all the time.


\[ ALE = \sum_{i=1}^{n} F_i \cdot C_i \]
where:
\begin{itemize}
    \item $F_i$ is the estimated frequency of events of type $i$, and
    \item $C_i$ is the average loss expected per occurence of an event of type $i$
\end{itemize}

\section{Adversary modeling and security analysis}

\begin{dfnbox}{Adversary}{}
    An \dfntxt{adversary} is an entity that wants to violate a security policy in order to harm an asset.
    \begin{itemize}[noitemsep]
        \item \dfntxt{identity}: who are they?
        \item \dfntxt{objectives}: what assets the adversary might try to harm
        \item \dfntxt{methods}: the potential attack techniques or types of attacks
        \item \dfntxt{capabilities}: skills, knowledge, personnel, and opportunity
        % \item funding level -- how much money an attacker has
        % \item outsider or insider -- whether or not the adversary may have special permissions or privileges
    \end{itemize}
\end{dfnbox}

In designing computer security mechanisms, it is important to identify traits about potential adversaries. Some attributes may include:


Different adversaries can have wildly different objectives, methods, and capabilities.

\begin{dfnbox}{Security Analysis}{}
    \dfntxt{Security analysis} aims to identify vulnerabilities and overlooked threats, as well as ways to improve defense against such threats
\end{dfnbox}

Types of analysis:
\begin{itemize}
    \item Formal security evaluation: standardized testing to ensure essential features and security
    \item Internal vulnerability testing: internal team trying to find vulnerabilities
    \item External penetration testing: third-party audits to find vulnerabilities; often the most effective
\end{itemize}

Security analysis is a heavily involved process that may employ a variety of methodologies. For example, manual source code review, review of design documents, and various penetration testing techniques. It's important to be aware of potential vulnerabilities as we are writing code.

\section{Threat Modeling}
A threat model will identify possible adversaries, threats, and attack vectors. We need to list a set of assumptions about the threats as well as clarify what is in and out of the scope of possibilities.

\paragraph{Diagram-Driven Threat Model}
Threat model diagrams include assets, infrastructure, and defenses/mitigations, making apparent the possible attack vectors. Popular examples include:
\begin{itemize}[noitemsep]
    \item \dfntxt{Data Flow Diagrams} -- models all possible data routes
    \item \dfntxt{User Workflow Diagram} -- models how users interact with the program, both frontend and backend
    \item \dfntxt{Attack Trees} -- models all possible attack vectors like a flow chart; leaf nodes are initial actions
\end{itemize}

\begin{dfnbox}{STRIDE}{stride}
    \dfntxt{STRIDE} is a model for identifying computer security threats.
    \begin{itemize}[noitemsep]
        \item \dfntxt{Spoofing} -- attacker impersonates another user, or malicious server posing as a legitimate server
        \item \dfntxt{Tampering} -- altering data without proper authorization; can occur when data is stored, processed
        \item \dfntxt{Repudiation} -- lying about past actions (e.g. denying/claiming that something happened)
        \item \dfntxt{Information Disclosure} -- exposure of confidential information without authorization
        \item \dfntxt{Denial of Service} -- render service unusable or unreliable for users
        \item \dfntxt{Elevation of Privilege} -- an unprivileged user gains privileges
    \end{itemize}
\end{dfnbox}

\section{Threat Model Gaps}
Often, wrong assumptions about risk or focus on wrong threats will lead to gaps between our threat model and what can realistically happen (e.g. if we don't account for something, but it does happen).

\paragraph{Changing Times}
New adversaries, technologies, software, and controls means we need to constantly adjust our threat model.

\section{Design Principles}
\begin{enumerate}
    \item Simplicity and necessity; complexity increases risks (KISS -- keep it simple, stupid)
    \item Safe Defaults -- get security out of the box; users rarely change defaults
    \item Open Design -- don't rely on the secrecy of our code; it will leak
    \item Complete Mediation -- never assume access is safe; always check access is allowed
    \item Least Privilege -- don't give principals extraneous privileges; limit impact of compromise
    \item Defense in depth -- multiple layers of security; don't rely on only one security control
    \item Security by design -- think about security throughout development, not an afterthought
    \item Design for evolution -- allow for change for whenever it's needed
\end{enumerate}

\section{Review}
CIA Triad, Golden principles, trusted vs. trustworthy, confidentialty vs. privacy.

TODO: add more review stuff from slides here; flesh out notes to reflect review

\chapter{Cryptography}
\paragraph{Cryptographic Rules to Remember}
\begin{enumerate}
    \item Do not design your own cryptographic protocols or algorithms.
    \item \dfntxt{Kerckhoff's Principle} -- security should only come from the secrecy of the crytographic key, NOT the algorithm or code.
    \item Encryption only provides confidentiality, not integrity.
\end{enumerate}

\section{Introduction}

\begin{dfnbox}{Cipher, Plain Text, Cipher Text}{}
    A \dfntxt{cipher} is any encryption or decryption algorithm. A \dfntxt{plaintext} message is vulnerable, usually prior to cipher. A \dfntxt{ciphertext} message is secure, usually after cipher is applied.
\end{dfnbox}

\begin{dfnbox}{Cryptographic Key}{}
    A \dfntxt{cryptographic key} is a value which is used to decrypt cipher text; should be relatively large and remain private.
\end{dfnbox}

The \dfntxt{key space} is the set of all possible cryptographic keys. It should be large enough such that it would be impractical to try every possible key. For example, AES-256 uses 256 bit keys. Even a thermodynamically perfect computer with the power of the sun could not even count through $2^{256}$ keys, much less guess and check them.

Some possible threats to encryption may be:
\begin{itemize}
    \item Brute force attack -- guess and check all keys
    \item Algorithmic break -- some flaw in the algorithm
\end{itemize}

Some possible adversaries include:
\begin{itemize}
    \item Passive -- just listens to communications
    \item Active -- can modify data
\end{itemize}

\begin{dfnbox}{Information-Theoretic Security}{}
    We say information has \dfntxt{information-theoretic security} if given \textbf{unlimited} computer power and time, an attacker could not recover the plaintext from the ciphertext.
\end{dfnbox}

\begin{dfnbox}{Computational Security}{}
    We say information has \dfntxt{computational security} if given \textbf{fixed} computer power and time, an attacker could not recover the plaintext from the ciphertext.
\end{dfnbox}

\begin{dfnbox}{Stream Cipher, Block Cipher}{}
    A \dfntxt{stream cipher} encrypts information one bit at a time.     A \dfntxt{block cipher} encrypts information in blocks.
\end{dfnbox}

\section{Symmetric Encryption Model}

\begin{dfnbox}{Symmetric-Key Algorithm}{}
    A \dfntxt{symmetric-key algorithm} encrypts plaintext and decrypts ciphertext using the same cryptographic key.
\end{dfnbox}

\begin{dfnbox}{One-Time Pad (OTP)}{}
    The \dfntxt{one-time pad} is a symmetric stream cipher that XOR's a message with a key. The resulting ciphertext is information theoretic so long as the following are met:
    \begin{itemize}[noitemsep]
        \item Key must be as long as the plaintext
        \item Key must be random
        \item Key must never be reused
        \item Key must be kept completely secret
   \end{itemize}
\end{dfnbox}

Many modern cryptographic algorithms work by taking a small cryptographic key and expanding it into a sufficiently large one-time pad key.


\begin{dfnbox}{Advanced Encryption Standard (AES)}{}
    \dfntxt{AES} is the most common symmetric block cipher, providing computational security.
    \begin{itemize}[noitemsep]
        \item Messages are split into 128-bit blocks (with padding)
        \item Cryptographic key is 128, 196, or 256 bits long
        \item Provides computational security
        \item A single bit changed should change (on average) 50\% of the ciphertext
    \end{itemize}
    In addition, different block modes help to remove patterns among blocks.
\end{dfnbox}

\section{Asymmetric Encryption Model}

\begin{dfnbox}{Asymmetric Encryption, Public Key, Private Key}{}
    \dfntxt{Asymmetric encryption} utilizes two cryptographic keys: a \dfntxt{public key} which encrypts plaintext, and a \dfntxt{private key} which decrypts ciphertext.
\end{dfnbox}

Unfortunately, public key encryption is orders of magnitude slower than symmetric key encryption. We can circumvent this through hybrid encryption.

\begin{dfnbox}{Hybrid Encryption, Key Wrap}{}
    \dfntxt{Hybrid encryption} incorporates both symmetric key and public key encryption. We encrypt our plaintext using a symmetric key, and we send both the encrypted ciphertext and the symmetric key encrypted using the other party's public key. This encrypted key is called a \dfntxt{key wrap}.
\end{dfnbox}

\begin{dfnbox}{Padding}{}
    Many encryption algorithms \dfntxt{pad} messages to:
    \begin{itemize}[noitemsep]
        \item ensure the message is properly formatted
        \item prevent attacks by adding random noise
    \end{itemize}
\end{dfnbox}

Suppose we only need to send a single integer. While the key space is large, the message space is small. Thus, an attacker could guess and check all possible messages until it matches the encrypted message.

There are many ways to pad a message. Generally, we want to use the optimal asymmetric encryption padding (OAEP).

\begin{dfnbox}{RSA}{}
    \dfntxt{RSA} is a common and mathematically simple cryptographic algorithm that provides computational security.
\end{dfnbox}

\begin{codebox}{Basic RSA Encryption using C\#}{}{}
    \begin{amzcode}{csharp}
        var message = "Hello World!";
        var plaintext = Encoding.ASCII.GetString(ciphertext);
        var rsa = RSA.Create(2048);
        var public_key = rsa.ExportRSAPublicKeyPem();
        var private_key = rsa.exportRSAPrivateKeyPem();

        var ciphertext = rsa.Encrypt(plaintext, RSAEncryptionPadding.OaepSHA256);

        var decrypted = rsa.Decrypt(ciphertext, RSAEncryptionPadding.OaepSHA256);
        var decrypted_plaintext = Encoding.ASCII.GetString(decrypted);
    \end{amzcode}
\end{codebox}

\section{Digital Signatures}

\begin{dfnbox}{Digital Signature}{}
    We can \dfntxt{digitally sign} information to verify that we made it. In this context, we use the \dfntxt{private key} to sign data, and others use the \dfntxt{public key} to verify a signature.
\end{dfnbox}

Digital signatures provide three security properties:
\begin{enumerate}[noitemsep]
    \item Data origin authentication -- the data comes from the owner of the private key
    \item Data integrity -- the data has not changed since it was sent
    \item Non-repudiation -- the sender cannot later claim to have not sent the data
\end{enumerate}

We avoid using the same key for signing and for cryptography because:
\begin{enumerate}[noitemsep]
    \item If our private key gets stolen, someone can then decrypt our data \textbf{and} forge digital signatures.
    \item There can be mathematical interactions between encryption and signing that can reveal information about our key.
\end{enumerate}


Similar to encryption algorithms, there are signing algorithms that create digital signatures and verification algorithms that verify digital signatures. In addition, we still pad our messages before signing to ensure the message is formatted and to prevent some (relatively esoteric) attacks.

Data is hashed before signed, and different key pairs should be used for encryption/decryption and signing/verification.

\section{Cryptographic Hash Functions}

\begin{dfnbox}{Hash Function}{}
    A \dfntxt{hash function} takes an arbitrary length string and outputs a unique fixed output length string.
    \tcblower
    \[ H : 2^* \to 2^n \]
\end{dfnbox}

Usage:
\begin{itemize}[noitemsep]
    \item $H$ can be applied to data of any size
    \item $H$ outputs a fixed length data
    \item $H$ is fast to compute
\end{itemize}

Security properties:
\begin{itemize}[noitemsep]
    \item \dfntxt{One-way property}: Theoretically impossible to find the original message from the hash; one hashed string maps to an infinite amount of input strings
    \item \dfntxt{Weak collision resistance}: Given an input, it's computationally impossible to find another input that produces the same hash.
    \item \dfntxt{Strong collision resistance}: It's computationally impossible to find any pair of distinct inputs that produce the same hash.
\end{itemize}

\begin{dfnbox}{SHA}{}
    \dfntxt{SHA} is a common hash function.
\end{dfnbox}

\begin{exbox}{Data Integrity}{}
    \begin{itemize}
        \item When sending data, first hash it and send the hash along with the data
        \item When receiving the data, first hash it and check that the calculated hash matches the one that was received
        \item TODO: finish from slides
    \end{itemize}
\end{exbox}

\begin{exbox}{Password Storage}{}
    Instead of storing passwords in plaintext, the server stores the hashed passwords.

    Hashing at client and then sending to server is flawed!
    \begin{itemize}
        \item If an attacker steals the hashed passwords, an attack can simply log in using the hashed passwords.
    \end{itemize}
\end{exbox}

\section{Message Authentication Codes}
\begin{itemize}
    \item Symetric-key equivalent to digital signatures
    \item Provides data origin authentication and data integrity (Only for two people)
    \item Does NOT provide non-repudiation (at least two people will have the symmetric key)
\end{itemize}

\begin{dfnbox}{Tag}{}

\end{dfnbox}

\begin{dfnbox}{Hash-Based Message Authentication Code (HMAC)}{}
    Can be used with any cryptographic hash function, only use with safe functions (e.g. HMAC-SHA256)
\end{dfnbox}

\begin{dfnbox}{CMAC}{}
    Based on symmetric encryption using CBC mode
\end{dfnbox}


\begin{dfnbox}{UMAC}{}
    Based on universal hashing; pick a hash function based on the key, then encrypt the digest
\end{dfnbox}

Again, don't reuse the same key for encryption and decryption

\begin{codebox}{Simple HMAC in C\#}{}{}
    \begin{amzcode}{csharp}
using System.Security.Cryptography;
using System.Text;

var message = "Hello World!";
var plaintext = Encoding.ASCII.GetBytes(message);

var digest = SHA256.HashData(plaintext);
var digest2 = SHA256.HashData(plaintext);

// Verify the two digests are the same
digest.SequenceEqual(digest2)

var receivedtext = "Gello World!";
var key = RandomNumberGenerator.GetBytes(512);
var calculatedMAC = HMACSHA256.HashData(key, plaintext);
var receivedMAC = HMACSHA256.HashData(key, receivedtext);

// This will be false
calculatedMAC.SequenceEqual(receivedMAC);
    \end{amzcode}
\end{codebox}

\section{Passwords}

\begin{dfnbox}{Username, Password}{}
    A \dfntxt{password} is a piece of secret information, typically a string of easily-typed characters, that is used to authenticate a user.
\end{dfnbox}


Passwords usually have an associated account with a username, public or secret. We are more concerned with the bits of the password, not necessarily the characters. As such, we need to have a deterministic way of converting characters to bits, whether it be ASCII or UTF-8.

Advantages of passwords:
\begin{itemize}[noitemsep]
    \item Simple and easy to learn
    \item Free
    \item No physical load to carry
    \item Usually easy to recover lost access
    \item Easily delegated (e.g. sharing Netflix passwords)
\end{itemize}

Disadvantages:
\begin{itemize}
    \item Hard to create random passwords (theoretical key space is large, but practical key space is small)
    \item Hard to remember good passwords
    \item Easy to reuse passwords
\end{itemize}

\begin{dfnbox}{Password Composition Policies (PCP)}{}
    A \dfntxt{password composition policy} specifies requirements about creating a password, such as minimum and maximum password length, or character requirements and restrictions.
\end{dfnbox}

Although intended to improve password strength, PCPs often backfire. It makes a lot of users recycle the same passwords. Similarly, forced password changes often backfire as most users, tech-savvy or not, will increment their password like ``hello1'', ``hello2''. This predictable pattern allows attackers to easily guess passwords whenever the next forced change happens.

\begin{dfnbox}{Passkey}{}
    Passwords can be changed into cryptographic keys called \dfntxt{passkeys}.
\end{dfnbox}

PBKDF2 is a common function. Modern algorithms like Argon2id can also be used.

\section{Password Authentication}


\begin{exbox}{Most Basic Password Authentication}{}
    Registration:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to the website
        \item Website stores the info
    \end{itemize}
    Authentication:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to the website
        \item Website compares the sent values with the stored values
    \end{itemize}
    \tcblower
    Some flaws:
    \begin{itemize}
        \item Data can be intercepted when sending to the server; need to encrypt communication between user and server
        \item Phishing: attacker tricks user into giving the attacker their info; hard to mitigate, could use password managers or hardware security tokens
        \item Online password guessing; have to rate limit authentication attempts, can also require strong passwords
        \item Password database theft
    \end{itemize}
\end{exbox}


\begin{exbox}{Most Basic Password Authentication}{}
    Registration:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to the website
        \item Website hashes the info, then stores the info
    \end{itemize}
    Authentication:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to the website
        \item Website compares the sent values with the stored values
    \end{itemize}
\end{exbox}

\amzindex
\end{document}
