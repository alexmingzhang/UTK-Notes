\documentclass[12pt]{report}

\usepackage[margin=1in]{geometry}
\usepackage[code,fastcompile]{amznotes}
\usepackage{enumitem}
\usepackage{tabularx}

\title{\textbf{Introduction to Cybersecurity}\\
\large UT Knoxville, Spring 2023, COSC 366}
\author{Alex Zhang}

\begin{document}

\maketitle
\tableofcontents

\chapter{Security Concepts and Principles}

\section{Fundamental Goals of Computer Security}

\begin{dfnbox}{Computer Security}{computer-security}
    \dfntxt{Computer security} is the practice of protecting computer-related assets from unauthorized actions, either by preventing such actions or detecting and recovering from them.
\end{dfnbox}

The goal of \nameref{dfn:computer-security} is to help users complete their desired task safely, without short or long term risks.  To do this, we support computer-based services by providing essential security properties.

\begin{dfnbox}{Confidentiality, Integrity, Availablity (CIA)}{cia}
    \begin{itemize}[noitemsep]
        \item \dfntxt{Confidentiality}: only authorized parties can access data, whether at rest or in motion (i.e. being transmitted)
        \item \dfntxt{Integrity}: data, software, or hardware remaining unchanged, except by authorized parties
        \item \dfntxt{Availability}: information, services, and computing resources are available for authorized use
    \end{itemize}
    Together, these form the \dfntxt{CIA triad}.
\end{dfnbox}

\begin{dfnbox}{Principal, Privilege}{}
    A \dfntxt{principal} is an entity with a given identity, such as a user, service, or system process. A \dfntxt{privilege} defines what a principal can do, such as read/write/execute permissions.
\end{dfnbox}

In addition to the CIA triad, we also have three security properties relating to principals.
\begin{dfnbox}{Authentication, Authorization, Auditability (Golden Principles)}{}
    The \dfntxt{Golden Principles} are three security properties regarding principals:

    \begin{itemize}[noitemsep]
        \item \dfntxt{Authentication}: assurance that a principal is who they say they are
        \item \dfntxt{Authorization}: proof that an entity has the necessary privilege to take the request action; most commonly done by authenticating a principal, and lookup up its privileges
        \item \dfntxt{Auditability}: ability to identify principals responsible for past actions
    \end{itemize}

\end{dfnbox}

Auditability (or accountability) gives away two key things: who conducted the attack and the methods by which an attack was made.

\begin{dfnbox}{Trustworthy, Trusted}{}
    Something is \dfntxt{trustworthy} if it deserves our confidence.     Something is \dfntxt{trusted} if it has our confidence.

\end{dfnbox}

\begin{dfnbox}{Privacy, Confidentiality}{}
    \dfntxt{Privacy} is a sense of being in control of access that others have to ourselves. It deals exclusively with people. \dfntxt{Confidentiality} is an extension of privacy to also include personally sensitive data.
\end{dfnbox}

\section{Computer security policies and attacks}

\begin{dfnbox}{Asset}{asset}
    An \dfntxt{asset} is a resource we want to protect, such as information, software, hardware, or computing/communications services.
\end{dfnbox}

Note that asset can refer to any tangible or intangible resources.

\begin{dfnbox}{Security Policy}{}
    A \dfntxt{security policy} specifies the design intent of a system's rules and practices (i.e. what the system is supposed to do and not do).
\end{dfnbox}

\begin{dfnbox}{Adversary}{}
    An \dfntxt{adversary} is an entity who wants to violate a security policy to harm an asset. Can also be called ``threat agents'' or ``threat actors''.
\end{dfnbox}

A formal security policy should precisely define each possible system state as either authorized (secure) or unauthorized (non-secure). Non-secure states raise the potential for attacks to happen.

\begin{dfnbox}{Threat}{}
    A \dfntxt{threat} is any combination of circumstances and/or entities that allow harm to assets or cause security violations.
\end{dfnbox}

\begin{dfnbox}{Attack, Attack Vector}{attack}
    An \dfntxt{attack} is a deliberate attempt to cause a security violation. An \dfntxt{attack vector} is the specific methods and steps by which an attack was executed.

\end{dfnbox}

\begin{dfnbox}{Mitigation}{mitigation}
    \dfntxt{Mitigation} describes countermeasures to reduce the chance of a threat being actualized or lessen the cost of a successful attack.
\end{dfnbox}

\nameref{dfn:mitigation} can include operational and management processes, software controls, and other security mechanisms.

\begin{exbox}{House Security Policy}{house}
    Consider this simple security policy for a house: no one is allowed in the house unless accompanied by a family member, and only family members are authorized to take things out of the house.
    \begin{itemize}[noitemsep]
        \item The presence of someone who wants to steal an asset from our house is a \textbf{threat}.
        \item An unaccompanied stranger in the house is a \textbf{security violation}.
        \item An unlocked door is a \textbf{vulnerability}.
        \item A stranger entering through the unlocked door and stealing a television is an \textbf{attack}.
        \item Entry through the unlocked door is an \textbf{attack vector}.
    \end{itemize}
\end{exbox}

\section{Risk, risk assessment, and modeling expected losses}

\begin{dfnbox}{Risk}{risk}
    A \dfntxt{risk} is the expected loss of assets due to future attacks.
\end{dfnbox}

There are two ways we assess risk: \dfntxt{quantitative} and \dfntxt{qualitative} risk assessment.
\begin{itemize}
    \item \dfntxt{Quantitative} risk assessment computes numerical estimate of risk
    \item \dfntxt{Qualitative} risk assessment compares risks relative to each other
\end{itemize}

Quantitative risk assessment is more suited for incidents that occur regularly, with historical data and stable statistics to generate probability estimates. However, computer security incidents occur so infrequently that any estimate of probability likely isn't precise. Thus, qualitative risk assessment is usually more practical. For each asset or asset class, their relevant threats are categorized based on probability of happening and impact if it happened.

Precise estimates of risk are rarely possible in practice, so qualitative risk assessment is usually yields more informed decisions. A popular equation for modeling risk is:
\[ R = T \cdot V \cdot C \]
where:
\begin{itemize}
    \item $T$ is the probability of an attack happening,
    \item $V$ is the probability such a vulnerability exists, and
    \item $C$ is cost of a successful attack, both tangible and intangible costs
\end{itemize}

$C$ can encompass tangible losses like money or intangible losses like reputation. Whatever model we use, we can then model expected losses as such:

In risk assessment, we ask ourselves these questions:
\begin{enumerate}
    \item What assets are most valuable, and what are their values?
    \item What system vulnerabilities exist?
    \item
\end{enumerate}

In answering these questions, it becomes apparant we cannot employ strictly quantitative risk assessment. A popular model for qualitative risk assessment is the \nameref{dfn:dread} model:

\begin{dfnbox}{DREAD}{dread}
    \dfntxt{DREAD} is a method of qualitative risk assessment using a subjective scaled rating system for five attributes.

    \begin{center}\begin{tabular}{r | l | l}
        Attribute & 10 & 1 \\ \hline
        \dfntxt{Damage Potential} & data is extremely sensitive & data is worthless \\
        \dfntxt{Reproducibility} & works every time & works only once \\
        \dfntxt{Exploitability} & anyone can mount an attack & requires a nation state \\
        \dfntxt{Affected Users} & 91-100\% of users & 0\% of users \\
        \dfntxt{Discoverability} & threat is obviously apparent & threat is undetectable
    \end{tabular}\end{center}

    The final DREAD score takes the average of all five attributes.
\end{dfnbox}

A common criticism of \nameref{dfn:dread} is that rating discoverability might reward security through obscurity. People will sometimes omit discoverability, or simply assign it the maximum value all the time.


\[ ALE = \sum_{i=1}^{n} F_i \cdot C_i \]
where:
\begin{itemize}
    \item $F_i$ is the estimated frequency of events of type $i$, and
    \item $C_i$ is the average loss expected per occurence of an event of type $i$
\end{itemize}

\section{Adversary modeling and security analysis}

\begin{dfnbox}{Adversary}{}
    An \dfntxt{adversary} is an entity that wants to violate a security policy in order to harm an asset.
    \begin{itemize}[noitemsep]
        \item \dfntxt{identity}: who are they?
        \item \dfntxt{objectives}: what assets the adversary might try to harm
        \item \dfntxt{methods}: the potential attack techniques or types of attacks
        \item \dfntxt{capabilities}: skills, knowledge, personnel, and opportunity
        % \item funding level -- how much money an attacker has
        % \item outsider or insider -- whether or not the adversary may have special permissions or privileges
    \end{itemize}
\end{dfnbox}

In designing computer security mechanisms, it is important to think like an adversary. Try to enumerate what methods might they use, and design around them. Different adversaries can have wildly different objectives, methods, and capabilities.

\begin{dfnbox}{Security Analysis}{}
    \dfntxt{Security analysis} aims to identify vulnerabilities and overlooked threats, as well as ways to improve defense against such threats
\end{dfnbox}

Types of analysis include:
\begin{itemize}[noitemsep]
    \item \dfntxt{Formal security evaluation}: standardized testing to ensure essential features and security
    \item \dfntxt{Internal vulnerability testing}: internal team trying to find vulnerabilities
    \item \dfntxt{External penetration testing}: third-party audits to find vulnerabilities; often the most effective
\end{itemize}

Security analysis is a heavily involved process that may employ a variety of methodologies. For example, manual source code review, review of design documents, and various penetration testing techniques. It's important to be aware of potential vulnerabilities as we are writing code.

\section{Threat Modeling}
A threat model will identify possible adversaries, threats, and attack vectors. We need to list a set of assumptions about the threats as well as clarify what is in and out of the scope of possibilities.

\paragraph{Diagram-Driven Threat Model}
Threat model diagrams include assets, infrastructure, and defenses/mitigations, making apparent the possible attack vectors. Popular examples include:
\begin{itemize}[noitemsep]
    \item \dfntxt{Data Flow Diagrams:} models all possible data routes
    \item \dfntxt{User Workflow Diagram:} models how users interact with the program, both frontend and backend
    \item \dfntxt{Attack Trees:} models all possible attack vectors like a flow chart; leaf nodes are initial actions
\end{itemize}

\begin{dfnbox}{STRIDE}{stride}
    \dfntxt{STRIDE} is a model for identifying computer security threats.
    \begin{itemize}[noitemsep]
        \item \dfntxt{Spoofing:} attacker impersonates another user, or malicious server posing as a legitimate server
        \item \dfntxt{Tampering:} altering data without proper authorization; can occur when data is stored, processed
        \item \dfntxt{Repudiation:} lying about past actions (e.g. denying/claiming that something happened)
        \item \dfntxt{Information Disclosure:} exposure of confidential information without authorization
        \item \dfntxt{Denial of Service:} render service unusable or unreliable for users
        \item \dfntxt{Elevation of Privilege:} an unprivileged user gains privileges
    \end{itemize}
\end{dfnbox}

\section{Threat Model Gaps}
Often, wrong assumptions about risk or focus on wrong threats will lead to gaps between our threat model and what can realistically happen (e.g. if we don't account for something, but it does happen).

\paragraph{Changing Times}
New adversaries, technologies, software, and controls means we need to constantly adjust our threat model.

\section{Design Principles}
\begin{enumerate}
    \item Simplicity and necessity; complexity increases risks (KISS -- keep it simple, stupid)
    \item Safe Defaults -- get security out of the box; users rarely change defaults
    \item Open Design -- don't rely on the secrecy of our code; it will leak
    \item Complete Mediation -- never assume access is safe; always check access is allowed
    \item Least Privilege -- don't give principals extraneous privileges; limit impact of compromise
    \item Defense in depth -- multiple layers of security; don't rely on only one security control
    \item Security by design -- think about security throughout development, not an afterthought
    \item Design for evolution -- allow for change for whenever it's needed
\end{enumerate}

\section{Review}
CIA Triad, Golden principles, trusted vs. trustworthy, confidentialty vs. privacy.

TODO: add more review stuff from slides here; flesh out notes to reflect review

\chapter{Cryptography}

\paragraph{Cryptographic Rules to Remember}
\begin{enumerate}[noitemsep]
    \item Do not design your own cryptographic protocols or algorithms.
    \item \dfntxt{Kerckhoff's Principle} -- security should only come from the secrecy of the crytographic key, NOT the algorithm or code.
    \item Encryption only provides confidentiality, not integrity.
\end{enumerate}

\section{Introduction}

\begin{dfnbox}{Cipher, Plain Text, Cipher Text}{}
    A \dfntxt{cipher} is any encryption or decryption algorithm. A \dfntxt{plaintext} message is vulnerable, usually prior to cipher. A \dfntxt{ciphertext} message is secure, usually after cipher is applied.
\end{dfnbox}

\begin{dfnbox}{Cryptographic Key, Key Space}{}
    A \dfntxt{cryptographic key} is a value which is used to decrypt cipher text. It should be relatively large and remain private. The \dfntxt{key space} is the set of all possible cryptographic keys in a cipher. It should be large enough such that it would be impractical to try every possible key.
\end{dfnbox}

 For example, AES-256 uses 256 bit keys. The key space of AES-256 is $2^{256}$. Even a thermodynamically perfect computer with the power of the sun could not even count through $2^{256}$ keys, much less guess and check them.

Some possible threats to encryption may be:
\begin{itemize}[noitemsep]
    \item Brute force attack -- guess and check all keys
    \item Algorithmic break -- some flaw in the algorithm
\end{itemize}

Some possible adversaries include:
\begin{itemize}[noitemsep]
    \item Passive -- just listens to communications
    \item Active -- can modify data
\end{itemize}

\begin{dfnbox}{Information-Theoretic Security}{}
    We say information has \dfntxt{information-theoretic security} if given \textbf{unlimited} computer power and time, an attacker could not recover the plaintext from the ciphertext.
\end{dfnbox}

\begin{dfnbox}{Computational Security}{}
    We say information has \dfntxt{computational security} if given \textbf{fixed} computer power and time, an attacker could not recover the plaintext from the ciphertext.
\end{dfnbox}

\begin{dfnbox}{Stream Cipher, Block Cipher}{}
    A \dfntxt{stream cipher} encrypts information one bit at a time.     A \dfntxt{block cipher} encrypts information in blocks.
\end{dfnbox}

\section{Symmetric Encryption Model}

\begin{dfnbox}{Symmetric-Key Algorithm}{}
    A \dfntxt{symmetric-key algorithm} encrypts plaintext and decrypts ciphertext using the same cryptographic key.
\end{dfnbox}

\begin{dfnbox}{One-Time Pad (OTP)}{}
    The \dfntxt{one-time pad} is a symmetric stream cipher that simply XOR's a message with a key. The resulting ciphertext is information theoretic so long as the following are met:
    \begin{itemize}[noitemsep]
        \item Key must be as long as the plaintext
        \item Key must be random
        \item Key must never be reused
        \item Key must be kept completely secret
   \end{itemize}
\end{dfnbox}

Many modern cryptographic algorithms work by taking a small cryptographic key and expanding it into a sufficiently large one-time pad key.

\begin{dfnbox}{Advanced Encryption Standard (AES)}{}
    \dfntxt{AES} is the most common symmetric block cipher, providing computational security.
    \begin{itemize}[noitemsep]
        \item Messages are split into 128-bit blocks (with padding)
        \item Cryptographic key is 128, 196, or 256 bits long
        \item Provides computational security
        \item A single bit changed should change (on average) 50\% of the ciphertext
    \end{itemize}
    In addition, different block modes help to remove patterns among blocks.
\end{dfnbox}

\section{Asymmetric Encryption Model}

\begin{dfnbox}{Asymmetric Encryption, Public Key, Private Key}{}
    \dfntxt{Asymmetric encryption} utilizes two cryptographic keys: a \dfntxt{public key} which encrypts plaintext, and a \dfntxt{private key} which decrypts ciphertext.
\end{dfnbox}

Unfortunately, public key encryption is orders of magnitude slower than symmetric key encryption. We can incorporate both using hybrid encryption, providing the best of both worlds.

\begin{dfnbox}{Hybrid Encryption, Key Wrap}{}
    \dfntxt{Hybrid encryption} incorporates both symmetric key and public key encryption. We encrypt our plaintext using a symmetric key, and we send both the encrypted ciphertext and the symmetric key encrypted using the other party's public key. This encrypted key is called a \dfntxt{key wrap}.
\end{dfnbox}

\begin{dfnbox}{Padding}{}
    Many encryption algorithms \dfntxt{pad} messages to:
    \begin{itemize}[noitemsep]
        \item ensure the message is properly formatted
        \item prevent attacks by adding random noise
    \end{itemize}
\end{dfnbox}

Suppose we only need to send a single integer. While the key space is large, the message space is small. Thus, an attacker could guess and check all possible messages until it matches the encrypted message.

There are many ways to pad a message. Generally, we want to use the optimal asymmetric encryption padding (OAEP).

\begin{dfnbox}{RSA}{}
    \dfntxt{RSA} is a common and mathematically simple cryptographic algorithm that provides computational security.
\end{dfnbox}

\begin{codebox}{Basic RSA Encryption using C\#}{}{}
    \begin{amzcode}{csharp}
        var message = "Hello World!";
        var plaintext = Encoding.ASCII.GetString(ciphertext);
        var rsa = RSA.Create(2048);
        var public_key = rsa.ExportRSAPublicKeyPem();
        var private_key = rsa.exportRSAPrivateKeyPem();

        var ciphertext = rsa.Encrypt(plaintext, RSAEncryptionPadding.OaepSHA256);

        var decrypted = rsa.Decrypt(ciphertext, RSAEncryptionPadding.OaepSHA256);
        var decrypted_plaintext = Encoding.ASCII.GetString(decrypted);
    \end{amzcode}
\end{codebox}

\section{Digital Signatures}

\begin{dfnbox}{Digital Signature}{}
    \dfntxt{Digital signatures} verify that data came from the right person. The \dfntxt{private key} is used to sign data, and the \dfntxt{public key} to verify a signature.
\end{dfnbox}

Digital signatures provide three security properties:
\begin{enumerate}[noitemsep]
    \item Data origin authentication -- the data comes from the owner of the private key
    \item Data integrity -- the data has not changed since it was sent
    \item Non-repudiation -- the sender cannot later claim to have not sent the data
\end{enumerate}

It is \textbf{crucial} to avoid using the same key for signing and for cryptography because:
\begin{enumerate}[noitemsep]
    \item If our private key gets stolen, someone can then decrypt our data \textbf{and} forge digital signatures.
    \item There can be mathematical interactions between encryption and signing that can reveal information about our key.
\end{enumerate}


Similar to encryption algorithms, there are signing algorithms that create digital signatures and verification algorithms that verify digital signatures. In addition, we still pad our messages before signing to ensure the message is formatted and to prevent some (relatively esoteric) attacks.

Data is hashed before signed, and different key pairs should be used for encryption/decryption and signing/verification.

\section{Cryptographic Hash Functions}

\begin{dfnbox}{Hash Function}{}
    A \dfntxt{hash function} takes an arbitrary length string and outputs a unique fixed output length string.
    \tcblower
    \[ H : 2^* \to 2^n \]
\end{dfnbox}

Usage:
\begin{itemize}[noitemsep]
    \item $H$ can be applied to data of any size
    \item $H$ outputs a fixed length data
    \item $H$ is fast to compute
\end{itemize}

Security properties:
\begin{itemize}[noitemsep]
    \item \dfntxt{One-way property}: Theoretically impossible to find the original message from the hash; one hashed string maps to an infinite amount of input strings
    \item \dfntxt{Weak collision resistance}: Given an input, it's computationally impossible to find another input that produces the same hash.
    \item \dfntxt{Strong collision resistance}: It's computationally impossible to find any pair of distinct inputs that produce the same hash.
\end{itemize}

\begin{dfnbox}{SHA}{}
    \dfntxt{SHA} is a common hash function.
\end{dfnbox}

\begin{exbox}{Data Integrity}{}
    \begin{itemize}
        \item When sending data, first hash it and send the hash along with the data
        \item When receiving the data, first hash it and check that the calculated hash matches the one that was received
        \item TODO: finish from slides
    \end{itemize}
\end{exbox}

\begin{exbox}{Password Storage}{}
    Instead of storing passwords in plaintext, the server stores the hashed passwords.

    Hashing at client and then sending to server is flawed!
    \begin{itemize}
        \item If an attacker steals the hashed passwords, an attack can simply log in using the hashed passwords.
    \end{itemize}
\end{exbox}

\section{Message Authentication Codes}

\begin{dfnbox}{Message Authentication Code, Tag}{}
    A \dfntxt{message authentication code} or \dfntxt{tag} is a short piece of information used for authenticating a message (i.e. came from the right person).
\end{dfnbox}

\begin{itemize}[noitemsep]
    \item Symmetric-key equivalent to digital signatures
    \item Provides data origin authentication and data integrity (only for two people)
    \item Does NOT provide non-repudiation (at least two people will have the symmetric key)
\end{itemize}

\begin{dfnbox}{Hash-Based Message Authentication Code (HMAC)}{}
    Can be used with any cryptographic hash function, only use with safe functions (e.g. HMAC-SHA256)
\end{dfnbox}

\begin{dfnbox}{CMAC}{}
    Based on symmetric encryption using CBC mode
\end{dfnbox}


\begin{dfnbox}{UMAC}{}
    Based on universal hashing; pick a hash function based on the key, then encrypt the digest
\end{dfnbox}

Again, don't reuse the same key for encryption and decryption

\begin{codebox}{Simple HMAC in C\#}{}{}
    \begin{amzcode}{csharp}
using System.Security.Cryptography;
using System.Text;

var message = "Hello World!";
var plaintext = Encoding.ASCII.GetBytes(message);

var digest = SHA256.HashData(plaintext);
var digest2 = SHA256.HashData(plaintext);

// Verify the two digests are the same
digest.SequenceEqual(digest2)

var receivedtext = "Gello World!";
var key = RandomNumberGenerator.GetBytes(512);
var calculatedMAC = HMACSHA256.HashData(key, plaintext);
var receivedMAC = HMACSHA256.HashData(key, receivedtext);

// This will be false
calculatedMAC.SequenceEqual(receivedMAC);
    \end{amzcode}
\end{codebox}

\chapter{User Authentication}

\section{Passwords}

\begin{dfnbox}{Username, Password}{}
    A \dfntxt{password} is a piece of secret information, typically a string of easily-typed characters, that is used to authenticate a user.
\end{dfnbox}


Passwords usually have an associated account with a username, public or secret. We are more concerned with the bits of the password, not necessarily the characters. As such, we need to have a deterministic way of converting characters to bits, whether it be ASCII or UTF-8.

\begin{tabularx}{\linewidth}{| X | X |}
    \hline
    Advantages of passwords:
    \begin{itemize}[noitemsep,leftmargin=*]
        \item Simple and easy to learn
        \item Free
        \item No physical load to carry
        \item Usually easy to recover lost access
        \item Easily delegated (e.g. sharing Netflix passwords)
    \end{itemize}
    &
    Disadvantages of passwords:
    \begin{itemize}[noitemsep,leftmargin=*]
        \item Hard to create random passwords (theoretical key space is large, but practical key space is small)
        \item Hard to remember good passwords
        \item Easy to reuse passwords
    \end{itemize}
    \\ \hline
\end{tabularx}


\begin{dfnbox}{Password Composition Policies}{}
    A \dfntxt{password composition policy} specifies requirements about creating a password, such as minimum and maximum password length, or character requirements and restrictions.
\end{dfnbox}

Although intended to improve password strength, these composition policies often backfire. It makes a lot of users recycle the same passwords. Similarly, forced password changes often backfire as most users, tech-savvy or not, will increment their password like ``hello1'', ``hello2''. This predictable pattern allows attackers to easily guess passwords whenever the next forced change happens.

\begin{dfnbox}{Passkey}{}
    Passwords can be changed into cryptographic keys called \dfntxt{passkeys}.
\end{dfnbox}

PBKDF2 is a common function. Modern algorithms like Argon2id can also be used.

\section{Password Authentication}

\begin{exbox}{Simplest (and worst) password authentication}{}
    Registration:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to the website
        \item Website stores the username and password in plaintext
    \end{itemize}
    Authentication:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to the website
        \item Website compares the sent values with the stored values
    \end{itemize}
\end{exbox}

Some of the major flaws include:
\begin{itemize}[noitemsep]
    \item Data can be intercepted when sending to the server; need to encrypt communication between user and server
    \item \dfntxt{Phishing:} attacker tricks user into giving the attacker their info; hard to mitigate, could use password managers or hardware security tokens
    \item Online password guessing; have to rate limit authentication attempts, can also require strong passwords
    \item Password database theft
\end{itemize}

\begin{exbox}{Simple but better password authentication}{}
    Registration:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to the website
        \item Website hashes the password, then stores the info
    \end{itemize}
    Authentication:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to the website
        \item Website hashes the received password and compares the calculated hash
    \end{itemize}
\end{exbox}

This is much better, but there are still some pretty serious flaws:
\begin{itemize}[noitemsep]
    \item \dfntxt{Offline guessing:} if an attacker steals the database, then they can guess passwords until it matches one of the hashed passwords with no rate limit.
    \item \dfntxt{Rainbow Table Attack:} someone can simply create a table of password hashes for common passwords
\end{itemize}

\begin{exbox}{Salted Hashing}{}
    Registration:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to website
        \item Website generates some random bytes called a \dfntxt{salt}
        \item Website hashes the received password concatenated with the salt (similar to padding)
        \item Website stores username, and salt in plaintext as well as the hashed password
    \end{itemize}
    Authentication:
    \begin{itemize}[noitemsep]
        \item User sends a username and password to website
        \item Website retrieves the salt for the username
        \item Website hashes the received password along with salt
        \item Website compares the calculated hash with the stored hash
    \end{itemize}
\end{exbox}

This defeats generalized rainbow table attacks. In extreme situations, a motivated adversary can steal the database and use the salt to create a specialized rainbow table targeted against one person.

We can add more features for stronger security, such as:
\begin{itemize}[noitemsep]
    \item \dfntxt{Iterated Hashing:} Repeatedly hash the salt and password a large number of times; slows down brute force guessing; has minimal impact on legitimate authentications
    \item Specialized Functions: Use memory-intense and cache-intense functions; makes it hard to accelerate, reducing password guessing rate significantly (e.g. Argon2id, bcrypt/scrypt)
    \item Keyed Hash Function: Use a hash function that requires a cryptographic key (e.g. HMAC); if key isn't stolen, it will be impossible to conduct offline guessing
\end{itemize}

\begin{codebox}{Passwords with Salted Hashing in C\#}{}{}
    \begin{amzcode}{csharp}
using System.Security.Cryptography;
using System.Text;

var password = "hello";
var passwordBytes = Encoding.ASCII.GetBytes(password);

var salt = RandomNumberGenerator.GetBytes(32);

// hash for 100000 iterations
var hash = Rfc2898DeriveBytes.Pbkdf2(password, salt, 100000, HashAlgorithmName.SHA256, 32);

using BCrypt.Net;

// Returns a crazy string
var temp = BCrypt.Net.BCrypt.HashPassword(password);

// Should return true
BCrypt.Net.Bcrypt.Verify(password, temp);
    \end{amzcode}
\end{codebox}

\section{Account Recovery}

When a user forgets their password or their account gets compromised, it's important that the user can still recover that account. It's also important to not let the account recovery method be easier for an adversary than password authentication. Security is only as strong as its weakest link.

\begin{dfnbox}{Password Recovery, Account Recovery}{}
    \dfntxt{Password recovery} retrieves a user's lost password. \dfntxt{Account recovery} lets a user regain access to their account, requiring a password reset.
\end{dfnbox}

Password recovery is a sign that the server is storing passwords in plaintext, or they are simply encrypting them without hashing. Either way, pretty shit.

That's why account recovery should be the only way to restore an account. Some methods include:
\begin{itemize}[noitemsep]
    \item Email-Based Recovery: Send a link to the email account; makes accounts only as strong as the email
    \item SMS-based recovery: similar to email-based recovery; prone to sim swapping
    \item Security Questions: in practice, it's easy for attacker to learn answers to these questions
\end{itemize}

\begin{dfnbox}{Single Sign-On (SSO)}{}
    \dfntxt{Single Sign-On} lets a single identity provider handle authentication for multiple websites.
\end{dfnbox}

While SSO creates a single point of failure, most users already reuse the same password for multiple sites. If one of those sites has a breach, then the rest of their accounts are screwed. Why not just have one identity provider that handles authentication for multiple websites. It's easier for the user (don't have to create as many accounts), and in practice, most SSO providers have top-class security.

In the Single Sign-On, there are three parties: the user, relying party, and identifying party. When trying to authenticate with the relying party, we first request an authentication token from the identifying party. We then send that token to the relying party, who verifies the token is correct by asking the identifying party.


\begin{dfnbox}{CAPTCHA}{}
    \dfntxt{CAPTCHA} refers to any online test used to differentiate human and computer entities. It's a loose acronym of ``completely automated public Turing test to tell computers and humans apart''.
\end{dfnbox}

A popular and modern approach to CAPTCHA is \dfntxt{reCAPTCHA}. It measures all of your interactions with the website as well as other metrics to determine if you're a human. If it's not sure, it makes you do the traffic light clicking thing.


\section{Authentication Factors}
Authentication factors are used to verify you are who you say you are. They rely on something one or more of the following:
\begin{itemize}[noitemsep]
    \item something you \dfntxt{know} (like a secret PIN or password)
    \item something you \dfntxt{have} (like a phone or credit card)
    \item something you \dfntxt{are} (fingerprints, behaviors)
\end{itemize}

\begin{dfnbox}{Multi-Factor Authentication}{}
    \dfntxt{Single factor authentication} authenticates users using only one factor. \dfntxt{Two-factor authentication (2FA)} authenticates using two distinct factors, most commonly a password and something you have. \dfntxt{Three-factor authentication (3FA)} is the most secure but usually not practical.
\end{dfnbox}

2FA substantially increases the security of accounts, but it needs to be carefully implemented to avoid usability issues.

Something you have:
\begin{itemize}[noitemsep]
    \item In your possession, trivial to authenticate
    \item Nothing to remember
    \item If you don't have the item, you can't authenticate
    \item If someone steals the item, you have immediate access
    \item If you lose item, account recovery is difficult
\end{itemize}

We can use the thing you have by sending that thing a secret value.
\begin{itemize}[noitemsep]
    \item Service sends a secret value to your device (one-time password)
    \item You authenticate by entering the secret value
    \item Problem: easy to phish
\end{itemize}

Alternatively, we can just have some way to synchronize the secret value generation, so we only need to send a secret once.
\begin{itemize}[noitemsep]
    \item Service sends you a secret during account registration
    \item Secret is stored on your device
    \item The secret is used to generate the same one-time password on both the server and dev
    \item Authenticate by entering the value generated by your device.
    \item Problem: still easy to phish, but attacker would only have a one-time window
\end{itemize}

We could use some dedicated device for this.
\begin{itemize}[noitemsep]
    \item Dedicated device generates a public-key private-key pair
    \item Public key is sent to service during registration
    \item Device uses its private key to sign authentication requests
    \item Can be designed to avoid phishing and require presence
    \item Usually comes with some backup codes in case the device is broken; those can be prone to phishing
\end{itemize}

When it comes to something you are:
\begin{itemize}[noitemsep]
    \item Nothing to remember
    \item Nothing to carry
    \item Difficult to steal
    \item Usually requires specialized hardware; bad hardware is prone to error and/or security issues
    \item If you lose your biometric, how do you recover your account?
    \item Sharing biometrics is risky in the first place
\end{itemize}

Some examples include:
\begin{itemize}[noitemsep]
    \item Fingerprints -- lots of poorly designed hardware prone to fingerprint lifting or forging
    \item Facial Recognition -- similar looking people like siblings can log in too
    \item Iris Recognition -- specialized hardware costs a lot
    \item Brainwave Recognition --
    \item Behavior Biometrics -- e.g reCAPTCHA
    \item Walking Cadence -- how you walk
    \item Travel Patterns -- used by gov't to identify suspicious people
\end{itemize}

When using biometrics for an app, it's usually not being sent to the server. Instead, the OS will only decrypt shared secret after authenticating using biometrics.

\begin{notebox}{}
    When authentication with biometrics like fingerprints, we aren't actually sending biometric info to the server. When logging in, the website and local device create a secret passphrase, and the local device only sends the passphrase to the website when the local device verifies your biometric. This is not a form of 2FA. From the website's perspective, there's only a single factor of authentication.
\end{notebox}

\chapter{OS Security}
\section{Reference Monitor}

\begin{dfnbox}{Subject, Action, Object}{}
    A \dfntxt{subject} is any entity (such as a user or process) trying to take some \dfntxt{action} such as read, write, execute, start, shutdown, etc. The \dfntxt{object} receives the action, such as some memory, files, services, or devices.
\end{dfnbox}

The subject is usually authenticated, but not necessarily. We can sometimes have an unknown subject.

\begin{dfnbox}{Policy, Reference Monitor}{}
    \dfntxt{Policies} define what is allowed, usually parameterized by subject, action, and object. \dfntxt{Reference monitors} enforce a policy by checking actions, allowing subjects to execute an action if it conforms with the policy.
\end{dfnbox}

Whenever a subject tries to make an action, the reference monitor gets to decide whether it should be allowed. The reference monitor has to require:

\begin{itemize}
    \item \dfntxt{Complete Mediation} -- all actions must go through the reference monitor (also ensures complete logs)
    \item \dfntxt{Tamper-proof} -- users can't just manipulate the reference monitor; also includes tamper-proof logs
    \item \dfntxt{Verifiable} -- reference monitor must be easily analyzable (means its source code has to be small!)
    \item \dfntxt{Reliable Authentication and/or Authorization} -- authentication for subject identfication; authorization for bearer tokens
\end{itemize}

\begin{dfnbox}{Permission, Capability List}{}
    A \dfntxt{permission} is a pair of (action, object). The list of all permissions associated with a subject can be called a \dfntxt{capability list}.
\end{dfnbox}

\begin{dfnbox}{Capability-Based Access Control, Bearer Token}{}
    \dfntxt{Capability-Based Access Control} reference monitor issues \dfntxt{bearer tokens} which let anyone with the token take specific action(s).
\end{dfnbox}

An example of a bearer token would be the link-sharing system on Google Docs. The document creator can easily delegate links which allow those with the link to view or edit our document. Another example would be API tokens.

\begin{dfnbox}{Access Control List (ACL)}{}
    The \dfntxt{access control list} is the set of (subject, action) pairs associated with an object.
\end{dfnbox}

Some other access control paradigms include:
\begin{itemize}
    \item \dfntxt{Role-based access control (RBAC)} -- associates permissions with certain groups of users rather than users themselves.
    \item \dfntxt{Attribute-based access control (ABAC)} -- incorporates contextual information to access control decisions (e.g. subject's behavioral patterns, current location; action's time of day, current threat level; object's location on network, creation date, size)
    \item \dfntxt{Cryptographic access control} -- use cryptography for access control without a reference monitor
\end{itemize}

\section{Memory Protection}
We care about memory protection because of concurrent execution: multiple users and multiple processes at the same time. We need to isolate resources from each process and user.

\begin{dfnbox}{Virtual Memory}{}
The OS kernel mediates access to system memory, acting as a reference monitor. The kernel allocates memory using virtual addressing. The kernel also limits who can access what memory, preventing users/processes from accessing other memory. It also protects OS memory and provides mechanisms for shared memory access.
\end{dfnbox}

\begin{dfnbox}{Kenel Memory Segmentation}{}
    The kernel divides memory into segments---contiguous regions of memory. Each segment is assigned one or more modes (read, write, execute, mode, fault).
\end{dfnbox}

The latter two modes are used by the OS for specific uses. The kernel sets default modes when allocating memory. Memory segments with code is marked as executable. Memory segments with the heap and stack are marked as readable and writable, not executable (prevents arbitrary code execution). In accordance with the principle of least privilege, the process can further restrict its own permissions.

\section{Filesystem Access Control}

\begin{dfnbox}{Filesystem}{}
    A \dfntxt{filesystem} is a hierarchical structuring of directories and folders. It maintains per-file meta-data, including permissions.
\end{dfnbox}

In the context of filesystems, subjects are users, groups or processes; actions are read/write/execute, modify metadata, etc.; objects are files, directories, etc.

A filesystem categorizes subjects as such:
\begin{itemize}[noitemsep]
    \item Users are identified by a user id (UID)
    \item Groups are identified by a group id (GID) (for role-based access control)
    \item Processes are identified by a process id (PID)
\end{itemize}

\begin{dfnbox}{Special Actions}{}

\end{dfnbox}

Actions involving the filesystem include basic ones like read, write, execute, and list folder contents. Some special actions include:
\begin{itemize}[noitemsep]
    \item Execute a binary as the owning user (e.g. sudo)
    \item Execute as the primary group of the owning user
    \item Set ``sticky bit'' (disables changing name or file deletion)
\end{itemize}

Advanced actions include:
\begin{itemize}[noitemsep]
    \item Take ownership
    \item Change permissions
    \item Write attributes
    \item Inspect or modify memory (debugging permission)
\end{itemize}

\begin{exbox}{Linux Access Control}{}
    Linux uses the \dfntxt{user-group-others} (UGO) permission model which uses a highly condensed ACL. This:
    \begin{itemize}[noitemsep]
        \item limits subjects to either the owning user, primary group of the owning user, and everyone else, and
        \item limits actions to read, write, execute, and special permissions (directory travel is controlled by read, modify and write are considered the same)
    \end{itemize}
    When determining permissions for actions, Linux checks the following in order, letting the action happen if any one of these is true:
    \begin{enumerate}[noitemsep]
        \item Is the subject the owning user?
        \item Is the subject a member of the owning group?
        \item Do the file's default permissions allow this action?
    \end{enumerate}
    Note that permissions are not inherited (i.e. every object has its own permission list). Also, it's possible to let a subject access an object inside a directory that the subject cannot access (i.e. they can't discover the path, but can access the object if they know the path).

    In contrast to traditional ACLs which specifies every allowed subject action pairs associated with an object, UGO only cares about one user, one group, and lumps everyone else into ``other''.
\end{exbox}

\begin{exbox}{Windows Access Control}{}
    Windows follows role-based access control (RBAC) with the roles being groups. When an object is created, it inherits the permissions of the parent folder.
\end{exbox}

\section{Additional Topics}

\begin{dfnbox}{Hidden File}{}
    A \dfntxt{hidden file} has an attribute that indicates files which should be ignored when listing the contents of a directory.
\end{dfnbox}

On Linux, this is done be prepending a file name with a period. On Windows, it's part of the file metadata. This does not change any permissions regarding the file.

\begin{dfnbox}{inode}{}
    An \dfntxt{inode} is a chunk of data that contains file name, metadata, and where the actual data is stored on the hard drive.
\end{dfnbox}

Filenames are a reference to an inode. The inode is only deleted when all filename references to it are deleted.

\begin{dfnbox}{Filesystem Links}{}
    \dfntxt{Filesystem links} are data that directly associate a filename with an inode. It allows for more than one file to refer to the same data on the hard drive.
    \begin{itemize}[noitemsep]
        \item A \dfntxt{hard link} is an additional filename reference to an inode, managed by the underlying file system.
        \item A \dfntxt{symbolic link} (or symlink) is a text file that contains a single filename. The OS provides file utilities that will read and handle symlinks. It does not reference the inode, so it does not prevent the inode from being deleted.
    \end{itemize}
\end{dfnbox}

\amzindex
\end{document}
